

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>eptm_class &mdash; Apposed-Cortex Model 1.0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Apposed-Cortex Model
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Apposed-Cortex Model</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>eptm_class</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for eptm_class</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">MIT License</span>

<span class="sd">Copyright (c) [2021] [Alexander Nestor-Bergmann]</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">dill</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shapely.geometry</span> <span class="k">as</span> <span class="nn">geom</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">more_itertools</span> <span class="kn">import</span> <span class="n">consecutive_groups</span>
<span class="kn">from</span> <span class="nn">numpy.core.umath_tests</span> <span class="kn">import</span> <span class="n">inner1d</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">shuffle</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">splrep</span><span class="p">,</span> <span class="n">splev</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">cKDTree</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">ConvexHull</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">decimate</span><span class="p">,</span> <span class="n">savgol_filter</span>
<span class="kn">from</span> <span class="nn">shapely.affinity</span> <span class="kn">import</span> <span class="n">scale</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">NearestNeighbors</span>

<span class="kn">from</span> <span class="nn">src.concave_hull</span> <span class="kn">import</span> <span class="n">ConcaveHull</span>
<span class="kn">from</span> <span class="nn">src.cell_class</span> <span class="kn">import</span> <span class="n">Cell</span>
<span class="kn">from</span> <span class="nn">src.adhesion_class</span> <span class="kn">import</span> <span class="n">Adhesion</span>

<span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.size&#39;</span><span class="p">:</span> <span class="mi">22</span><span class="p">})</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rc</span><span class="p">(</span><span class="s1">&#39;font&#39;</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="s1">&#39;serif&#39;</span><span class="p">,</span> <span class="n">serif</span><span class="o">=</span><span class="s1">&#39;Times&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rc</span><span class="p">(</span><span class="s1">&#39;text&#39;</span><span class="p">,</span> <span class="n">usetex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">CURRENT_DIR</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>


<div class="viewcode-block" id="Epithelium"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium">[docs]</a><span class="k">class</span> <span class="nc">Epithelium</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to hold and manipulate all objects that constitute a tissue: cells, adhesion and boundaries.</span>

<span class="sd">    The adhesion objects, with their cell conection information, are stored here.  This information is passed to each</span>
<span class="sd">    cell as a list, rather than adhesion itself, for memory.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">param_dict</span><span class="o">=</span><span class="p">{},</span> <span class="n">tissue_type</span><span class="o">=</span><span class="s1">&#39;within_hexagon&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">disordered_tissue_params</span><span class="o">=</span><span class="p">{},</span> <span class="n">cell_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">eptm_kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialiser which sets up the class properties.</span>

<span class="sd">        :param radius: Radius of the initially circular cell.</span>
<span class="sd">        :param n: Number of nodes to discretise the cortex.</span>
<span class="sd">        :param param_dict: Dictionary with keys ``kappa``, ``omega0`` and ``delta`` with theit starting values.</span>
<span class="sd">        :param tissue_type: Can be ``&#39;within_hexagon&#39;`` or ``&#39;disordered&#39;``.</span>
<span class="sd">        :param verbose: Boolean, whether to print information to console.</span>
<span class="sd">        :param disordered_tissue_params: Dict of params to pass to ``create_disordered_tissue_in_ellipse``</span>
<span class="sd">        :param cell_kwargs: Dict of params to pass to ``_build_single_cell`` to initialise cell properties.</span>
<span class="sd">        :param eptm_kwargs: Any other parameters for initialising the epithelium.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Initialising epithelium&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1">#######</span>

        <span class="c1"># Initial radius of circular cell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="k">if</span> <span class="s1">&#39;delta&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="p">:</span>
            <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="s1">&#39;kappa&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="p">:</span>
            <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;kappa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-4</span>
        <span class="k">if</span> <span class="s1">&#39;omega0&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="p">:</span>
            <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;omega0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>

        <span class="k">if</span> <span class="n">tissue_type</span> <span class="o">==</span> <span class="s1">&#39;within_hexagon&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">within_hexagons</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_single_cell</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">param_dict</span><span class="o">=</span><span class="n">param_dict</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                    <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">cell_kwargs</span><span class="o">=</span><span class="n">cell_kwargs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">tissue_type</span> <span class="o">==</span> <span class="s1">&#39;disordered&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">within_hexagons</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_disordered_tissue_in_ellipse</span><span class="p">(</span><span class="n">param_dict</span><span class="o">=</span><span class="n">param_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">disordered_tissue_params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Can have only &quot;within_hexagon&quot; or &quot;disordered&quot; tissues&#39;</span><span class="p">)</span>

        <span class="c1"># Concave hull</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concave_hull_tolerance</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;concave_hull_tolerance&#39;</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">))</span>
        <span class="c1"># if radius &gt; 25:</span>
        <span class="c1">#     self.concave_hull_tolerance *= .1</span>

        <span class="c1">############### Solving parameters</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">last_num_internal_relaxes</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;last_num_internal_relaxes&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_elastic_relaxes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relax_dist_threshold</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;relax_dist_threshold&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_elastic_relax_steps</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_elastic_relax_steps&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elastic_relax_tol</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;elastic_relax_tol&#39;</span><span class="p">,</span> <span class="mf">2e-2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_equilibrium</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viscous_timescale</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;viscous_timescale&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viscous_cortex</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;viscous_cortex&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viscous_bulk</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;viscous_bulk&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_solve_success</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">use_mesh_coarsening</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;use_mesh_coarsening&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_mesh_refinement</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;use_mesh_refinement&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>


        <span class="c1">############## Adhesion properties</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_timescale</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;adhesion_timescale&#39;</span><span class="p">,</span> <span class="s1">&#39;slow&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_timescale</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;fast&quot;</span><span class="p">,</span> <span class="s2">&quot;slow&quot;</span><span class="p">],</span> <span class="s2">&quot;Error, adhesion timescale </span><span class="si">%s</span><span class="s2"> not valid.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_timescale</span>

        <span class="n">fast_on</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_timescale</span> <span class="o">==</span> <span class="s2">&quot;fast&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activate_fast_adhesions</span><span class="p">(</span><span class="n">fast_on</span><span class="p">)</span>

        <span class="c1"># Sidekick vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_active</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sidekick_active&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Second population of adhesions with different rates of turnover</span>
        <span class="n">slow_on</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_timescale</span> <span class="o">==</span> <span class="s2">&quot;slow&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activate_slow_adhesions</span><span class="p">(</span><span class="n">slow_on</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesion_lifespan</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;slow_adhesion_lifespan&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1">############### Initialise the boundary properties</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_bc</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;boundary_bc&#39;</span><span class="p">,</span> <span class="s1">&#39;fixed&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_stiffness_x</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;boundary_stiffness_x&#39;</span><span class="p">,</span> <span class="mf">2.5e-2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_stiffness_y</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;boundary_stiffness_y&#39;</span><span class="p">,</span> <span class="mf">2.5e-2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">posterior_pull_shift</span> <span class="o">=</span> <span class="n">eptm_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;posterior_pull_shift&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Stretch from posterior midgut.</span>

        <span class="c1"># Finish up</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">within_hexagons</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_adhesion_to_fixed_line_bool</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_all_rest_lengths_and_areas</span><span class="p">()</span>


<div class="viewcode-block" id="Epithelium.set_verbose"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_verbose">[docs]</a>    <span class="k">def</span> <span class="nf">set_verbose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Turn print statements on or off.</span>

<span class="sd">        :param verbose: Whether to print information to console.</span>
<span class="sd">        :type verbose:  bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span></div>

<div class="viewcode-block" id="Epithelium.verboseprint"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.verboseprint">[docs]</a>    <span class="k">def</span> <span class="nf">verboseprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function to print out details as code runs</span>

<span class="sd">        :param args:  Information to be printed to console.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="k">else</span> <span class="kc">None</span></div>
        <span class="c1"># print if self.verbose else lambda *args, **k: None</span>

<div class="viewcode-block" id="Epithelium.remove_redundant_member_variables"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.remove_redundant_member_variables">[docs]</a>    <span class="k">def</span> <span class="nf">remove_redundant_member_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deletes old, lingering variables that are taking up space&quot;&quot;&quot;</span>

        <span class="c1"># self.reference_boundary_adhesions = []</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;adhesion_friction_timescale&#39;</span><span class="p">):</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;adhesion_friction_timescale&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;slow_adhesion_persistence&#39;</span><span class="p">):</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;slow_adhesion_persistence&#39;</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;ICs&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;ICs&#39;</span><span class="p">)</span>
            <span class="c1"># if hasattr(cell, &#39;adhesion_density_dict&#39;):</span>
            <span class="c1">#     delattr(cell, &#39;adhesion_density_dict&#39;)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;collocation_adhesion_connections&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;collocation_adhesion_connections&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;collocation_adhesion_connections_identities&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;collocation_adhesion_connections_identities&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;deltaOld&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;deltaOld&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;deltaTarget&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;deltaTarget&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;endConditions&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;endConditions&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;extForce&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;extForce&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;extMoment&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;extMoment&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;identity&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;identity&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;kappaOld&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;kappaOld&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;kappaTarget&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;kappaTarget&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;knownEndVariables&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;knownEndVariables&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;knownICs&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;knownICs&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;myoForceOld&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;myoForceOld&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;myoForceTarget&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;myoForceTarget&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;nabo_spacing_dict&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;nabo_spacing_dict&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;omega0Old&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;omega0Old&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;omega0Target&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;omega0Target&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;pressureTarget&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;pressureTarget&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;sdkForceOld&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;sdkForceOld&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;sdkForceTarget&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;sdkForceTarget&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;sdkForce&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;sdkForce&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;theta0Old&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;theta0Old&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;thetaLOld&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;thetaLOld&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;theta0Target&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;theta0Target&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;thetaLTarget&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;thetaLTarget&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;variablesDict&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;variablesDict&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Epithelium.update_all_missing_member_variables"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.update_all_missing_member_variables">[docs]</a>    <span class="k">def</span> <span class="nf">update_all_missing_member_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initialse missing member variables that may have been created since the eptm was saved</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;relax_dist_threshold&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relax_dist_threshold</span> <span class="o">=</span> <span class="o">.</span><span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;max_elastic_relax_steps&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_elastic_relax_steps</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;elastic_relax_tol&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elastic_relax_tol</span> <span class="o">=</span> <span class="mf">5e-2</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;in_equilibrium&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">in_equilibrium</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;reference_boundary_adhesions&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;boundary_bc&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary_bc</span> <span class="o">=</span> <span class="s1">&#39;fixed&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;total_elastic_relaxes&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">total_elastic_relaxes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;viscous_timescale&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">viscous_timescale</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;viscous_bulk&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">viscous_bulk</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;viscous_cortex&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">viscous_cortex</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;sidekick_active&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_active</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># if not hasattr(self, &#39;sidekick_vertices&#39;):</span>
        <span class="c1">#     self.sidekick_vertices = []</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;sidekick_adhesions&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;use_mesh_coarsening&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_mesh_coarsening</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;use_mesh_refinement&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_mesh_refinement</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;slow_adhesions&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;slow_adhesions_active&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions_active</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;slow_adhesion_lifespan&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesion_lifespan</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;adhesion_shear_unbinding_factor&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_shear_unbinding_factor</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;boundary_cell&#39;</span><span class="p">):</span>
            <span class="n">initial_guessesA</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="p">[],</span>
                                <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="n">initial_guesses</span><span class="o">=</span><span class="n">initial_guessesA</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;boundary&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">prune_adhesion_data</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">y</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="s1">&#39;boundary&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span>
            <span class="c1"># self.boundary_cell.s_index_dict = {s: idx for (idx, s) in enumerate(self.boundary_cell.s)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="s1">&#39;boundary&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update_deformed_mesh_spacing</span><span class="p">()</span>


        <span class="c1"># Cell properties</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="o">!=</span> <span class="s1">&#39;boundary&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;relax_tol&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">relax_tol</span> <span class="o">=</span> <span class="mf">1e0</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;last_solve_status&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">last_solve_status</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;identity&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">identity</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;pref_area&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">pref_area</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;area_stiffness&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">area_stiffness</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;prestrain_indices_list&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_indices_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;pressure_on_off&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">pressure_on_off</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;adhesion_beta_scale_factor&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">adhesion_beta_scale_factor</span> <span class="o">=</span> <span class="mi">100</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;sidekick_adhesions&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">sidekick_adhesions</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># if not hasattr(cell, &#39;sidekick_adhesion_coords&#39;):</span>
                <span class="c1">#     cell.sidekick_adhesion_coords = []</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;sdk_stiffness&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">sdk_stiffness</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">omega0</span> <span class="o">*</span> <span class="mi">100</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;sdk_restlen&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">sdk_restlen</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># if not hasattr(cell, &#39;s_index_dict&#39;):</span>
                <span class="c1">#     cell.s_index_dict = {s: idx for (idx, s) in enumerate(cell.s)}</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;deformed_mesh_spacing&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">update_deformed_mesh_spacing</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;slow_adhesions&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">slow_adhesions</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;fast_adhesions_active&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">fast_adhesions_active</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;lagrangian_point_ids&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">lagrangian_point_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;prestrain_plot_offset&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_plot_offset</span> <span class="o">=</span> <span class="mf">0.9</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="s1">&#39;max_mesh_coarsen_fraction&#39;</span><span class="p">):</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">max_mesh_coarsen_fraction</span> <span class="o">=</span> <span class="mf">0.01</span></div>


<div class="viewcode-block" id="Epithelium.set_mesh_coarsening_fraction"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_mesh_coarsening_fraction">[docs]</a>    <span class="k">def</span> <span class="nf">set_mesh_coarsening_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_fraction_to_remove</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Specify what fraction of total nodes can be removed in coarsening</span>

<span class="sd">        :param max_fraction_to_remove: Maxiumum fraction of mesh nodes to remove in one pass, when adaptive.</span>
<span class="sd">        :type max_fraction_to_remove: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">max_mesh_coarsen_fraction</span> <span class="o">=</span> <span class="n">max_fraction_to_remove</span></div>

<div class="viewcode-block" id="Epithelium.double_mesh"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.double_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">double_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Puts new mesh points at mean locations of current.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">double_mesh</span><span class="p">()</span></div>

<div class="viewcode-block" id="Epithelium.remesh_all_cortices"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.remesh_all_cortices">[docs]</a>    <span class="k">def</span> <span class="nf">remesh_all_cortices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coarsen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">refine</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add/remove mesh nodes if spacing too big/small</span>

<span class="sd">        :param coarsen:  (Default value = True).  Boolean, whether to adaptively remove mesh nodes.</span>
<span class="sd">        :type coarsen:  bool</span>
<span class="sd">        :param refine:  (Default value = True).  Boolean, whether to adaptively add mesh nodes.</span>
<span class="sd">        :type refine:  bool</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If sdk is on, we need to store the positions as s values, not indices in s, so we can get them back</span>
        <span class="c1"># after the mesh changes</span>
        <span class="c1"># initialise a dict of empty sets to store vertices for every sdk point so we don&#39;t remove them in</span>
        <span class="c1"># coarsening</span>
        <span class="n">indices_to_keep</span> <span class="o">=</span> <span class="p">{</span><span class="n">identifier</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">identifier</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_active</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span><span class="p">:</span>
                <span class="n">indices_to_keep</span><span class="p">[</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_1</span><span class="o">.</span><span class="n">identifier</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_1_index</span><span class="p">)</span>
                <span class="n">indices_to_keep</span><span class="p">[</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_2</span><span class="o">.</span><span class="n">identifier</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_2_index</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">adaptive_mesh_update</span><span class="p">(</span><span class="n">coarsen</span><span class="o">=</span><span class="n">coarsen</span><span class="p">,</span> <span class="n">refine</span><span class="o">=</span><span class="n">refine</span><span class="p">,</span> <span class="n">nodes_to_keep</span><span class="o">=</span><span class="n">indices_to_keep</span><span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">identifier</span><span class="p">])</span>

        <span class="c1"># Get the local indices back from the curviliear coords.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_active</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span><span class="p">:</span>
                <span class="n">ad</span><span class="o">.</span><span class="n">update_local_cell_indices_with_s</span><span class="p">()</span>

        <span class="c1"># If we have slow adhesions, remove the ones where the node no longer exists and update the local index.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Create a dict of sets for cell s coords for fast lookup</span>
            <span class="n">cell_s_set_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
            <span class="n">remaining_slows</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Store the adhesions with coords that remain</span>
            <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span><span class="p">:</span>
                <span class="c1"># If both sides of the adhesion still exist, keep it.</span>
                <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">cell_1_s</span> <span class="ow">in</span> <span class="n">cell_s_set_dict</span><span class="p">[</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_1</span><span class="o">.</span><span class="n">identifier</span><span class="p">]</span> <span class="ow">and</span> \
                        <span class="n">ad</span><span class="o">.</span><span class="n">cell_2_s</span> <span class="ow">in</span> <span class="n">cell_s_set_dict</span><span class="p">[</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_2</span><span class="o">.</span><span class="n">identifier</span><span class="p">]:</span>
                    <span class="n">remaining_slows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ad</span><span class="p">)</span>
                    <span class="n">ad</span><span class="o">.</span><span class="n">update_local_cell_indices_with_s</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span> <span class="o">=</span> <span class="n">remaining_slows</span></div>


<div class="viewcode-block" id="Epithelium.adjust_intersections"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.adjust_intersections">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_intersections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies a hand-of-god correction to prevent intersections of cortices.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Applying hand-of-god hard-body correction&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">apply_hand_of_god_hard_body_correction</span><span class="p">()</span></div>


<div class="viewcode-block" id="Epithelium.set_adhesion_to_fixed_line_bool"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_adhesion_to_fixed_line_bool">[docs]</a>    <span class="k">def</span> <span class="nf">set_adhesion_to_fixed_line_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yes_no</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define whether the elements are adhering to fixed line (a fixed boundary, rather than other cells).</span>

<span class="sd">        :param yes_no:  Set to fixed line or not.</span>
<span class="sd">        :type yes_no: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Setting cells.fixed_adhesion to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">yes_no</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">fixedAdhesion</span> <span class="o">=</span> <span class="n">yes_no</span></div>


<div class="viewcode-block" id="Epithelium.set_adhesion_beta_scale_factor"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_adhesion_beta_scale_factor">[docs]</a>    <span class="k">def</span> <span class="nf">set_adhesion_beta_scale_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adhesion_beta_scale_factor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set the scale factor to normalise fast adhesion forces in the meanfield.</span>

<span class="sd">        :param adhesion_beta_scale_factor:  Exponential scaling factor.</span>
<span class="sd">        :type adhesion_beta_scale_factor:  float</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Setting cells.adhesion_beta_scale_factor to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">adhesion_beta_scale_factor</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">adhesion_beta_scale_factor</span> <span class="o">=</span> <span class="n">adhesion_beta_scale_factor</span></div>


<div class="viewcode-block" id="Epithelium.set_viscous_cortex"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_viscous_cortex">[docs]</a>    <span class="k">def</span> <span class="nf">set_viscous_cortex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on_off</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Specify if the cortex is viscous</span>

<span class="sd">        :param on_off: turn viscosity on or off</span>
<span class="sd">        :type on_off: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viscous_cortex</span> <span class="o">=</span> <span class="n">on_off</span></div>


<div class="viewcode-block" id="Epithelium.set_viscous_bluk"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_viscous_bluk">[docs]</a>    <span class="k">def</span> <span class="nf">set_viscous_bluk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on_off</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Specify if the area is viscous</span>

<span class="sd">        :param on_off: Turn viscous bulk on or off.</span>
<span class="sd">        :type on_off: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viscous_bulk</span> <span class="o">=</span> <span class="n">on_off</span></div>


<div class="viewcode-block" id="Epithelium.activate_fast_adhesions"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.activate_fast_adhesions">[docs]</a>    <span class="k">def</span> <span class="nf">activate_fast_adhesions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on_off</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Turn forces from fast adhesions on or off.  Even when off, fast adhesions are used to calculate active contractility.</span>

<span class="sd">        :param on_off: Turn forces from fast adhesions on or off.</span>
<span class="sd">        :type on_off: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">fast_adhesions_active</span> <span class="o">=</span> <span class="n">on_off</span></div>


<div class="viewcode-block" id="Epithelium.activate_slow_adhesions"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.activate_slow_adhesions">[docs]</a>    <span class="k">def</span> <span class="nf">activate_slow_adhesions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on_off</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Turn slow adhesion forces on or off</span>

<span class="sd">        :param on_off: Activate slow adhesions, or not.</span>
<span class="sd">        :type on_off: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions_active</span> <span class="o">=</span> <span class="n">on_off</span></div>


<div class="viewcode-block" id="Epithelium.activate_sidekick_adhesions"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.activate_sidekick_adhesions">[docs]</a>    <span class="k">def</span> <span class="nf">activate_sidekick_adhesions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on_off</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Turn sdk vertex forces on or off</span>

<span class="sd">        :param on_off:  Activate sidekick forces or not.</span>
<span class="sd">        :type on_off: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_active</span> <span class="o">=</span> <span class="n">on_off</span></div>


<div class="viewcode-block" id="Epithelium.set_sdk_stiffness"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_sdk_stiffness">[docs]</a>    <span class="k">def</span> <span class="nf">set_sdk_stiffness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stiffness</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the stiffness of an sdk bond</span>

<span class="sd">        :param stiffness:  The bond stiffness.</span>
<span class="sd">        :type stiffness: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">sdk_stiffness</span> <span class="o">=</span> <span class="n">stiffness</span></div>


<div class="viewcode-block" id="Epithelium.set_sdk_restlen"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_sdk_restlen">[docs]</a>    <span class="k">def</span> <span class="nf">set_sdk_restlen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest_len</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the stiffness of an sdk bond</span>

<span class="sd">        :param rest_len:  The bond rest length.</span>
<span class="sd">        :type rest_len: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">sdk_restlen</span> <span class="o">=</span> <span class="n">rest_len</span></div>


<div class="viewcode-block" id="Epithelium.update_all_rest_lengths_and_areas"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.update_all_rest_lengths_and_areas">[docs]</a>    <span class="k">def</span> <span class="nf">update_all_rest_lengths_and_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the rest lengths, S_0 &lt;- s, and areas of specified cortices under viscous model</span>

<span class="sd">        :param apply_to:  (Default value = &#39;all&#39;)  If not ``&#39;all&#39;``, a list of cell identifiers that the function will be applied to.</span>
<span class="sd">        :type apply_to: list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Updating all rest lengths&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">apply_to</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span> <span class="k">if</span> <span class="n">apply_to</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="k">else</span> <span class="n">apply_to</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">viscous_cortex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_all_rest_lengths</span><span class="p">(</span><span class="n">apply_to</span><span class="o">=</span><span class="n">apply_to</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">viscous_bulk</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_pref_areas</span><span class="p">(</span><span class="n">apply_to</span><span class="o">=</span><span class="n">apply_to</span><span class="p">)</span>

        <span class="c1"># If we have slow or sidekick adhesions, the s coordinates need to be updated to their new values after</span>
        <span class="c1"># the viscous update.</span>
        <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span><span class="p">:</span>
                <span class="n">ad</span><span class="o">.</span><span class="n">update_s_by_local_cell_indices</span><span class="p">()</span>
                <span class="n">ad</span><span class="o">.</span><span class="n">age</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span><span class="p">:</span>
                <span class="n">ad</span><span class="o">.</span><span class="n">update_s_by_local_cell_indices</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mesh_coarsening</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mesh_refinement</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remesh_all_cortices</span><span class="p">(</span><span class="n">coarsen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_mesh_coarsening</span><span class="p">,</span> <span class="n">refine</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_mesh_refinement</span><span class="p">)</span></div>


<div class="viewcode-block" id="Epithelium.update_all_rest_lengths"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.update_all_rest_lengths">[docs]</a>    <span class="k">def</span> <span class="nf">update_all_rest_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the rest lengths, S_0 &lt;- s, of specified cortices under viscous model</span>

<span class="sd">        :param apply_to:  (Default value = &#39;all&#39;)  If not ``&#39;all&#39;``, a list of cell identifiers that the function will be applied to.</span>
<span class="sd">        :type apply_to: list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Updating all rest lengths&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">apply_to</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span> <span class="k">if</span> <span class="n">apply_to</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="k">else</span> <span class="n">apply_to</span>

        <span class="c1"># Reset lengths</span>
        <span class="k">for</span> <span class="n">cell_ref</span> <span class="ow">in</span> <span class="n">apply_to</span><span class="p">:</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_ref</span><span class="p">]</span>
            <span class="n">total_len</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_length</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">viscous_timescale</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># \todo this is no longer implemented properly</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Haven&#39;t implemented viscoelasticity yet&quot;</span><span class="p">)</span>
                <span class="c1"># new_rest_len = cell.rest_len + (total_len - cell.rest_len)/self.viscous_timescale</span>
                <span class="c1"># cell.update_reference_configuration_to_current()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">update_reference_configuration_to_current</span><span class="p">()</span></div>


<div class="viewcode-block" id="Epithelium.update_pref_areas"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.update_pref_areas">[docs]</a>    <span class="k">def</span> <span class="nf">update_pref_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the preferred area of specified cells</span>

<span class="sd">        :param area:  (Default value = None)  New preferred area.</span>
<span class="sd">        :type area: float</span>
<span class="sd">        :param apply_to:  (Default value = &#39;all&#39;)  If not ``&#39;all&#39;``, a list of cell identifiers that the function will be applied to.</span>
<span class="sd">        :type apply_to: list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">apply_to</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span> <span class="k">if</span> <span class="n">apply_to</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="k">else</span> <span class="n">apply_to</span>

        <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">apply_to</span><span class="p">:</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">viscous_timescale</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cell_area</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">pref_area</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pref_area</span> <span class="o">+</span> <span class="p">(</span><span class="n">cell_area</span> <span class="o">-</span> <span class="n">cell</span><span class="o">.</span><span class="n">pref_area</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">viscous_timescale</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_pref_area</span> <span class="o">=</span> <span class="n">area</span> <span class="k">if</span> <span class="n">area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">pref_area</span> <span class="o">=</span> <span class="n">new_pref_area</span></div>


<div class="viewcode-block" id="Epithelium.update_pressures"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.update_pressures">[docs]</a>    <span class="k">def</span> <span class="nf">update_pressures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pressure</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the pressure acting on the cortex, from the cell bulk.</span>

<span class="sd">        :param pressure:  Magnitude of pressure force in cell bulk.</span>
<span class="sd">        :type pressure: float</span>
<span class="sd">        :param apply_to:  (Default value = &#39;all&#39;)  If not ``&#39;all&#39;``, a list of cell identifiers that the function will be applied to.</span>
<span class="sd">        :type apply_to: list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">apply_to</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span> <span class="k">if</span> <span class="n">apply_to</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="k">else</span> <span class="n">apply_to</span>

        <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">apply_to</span><span class="p">:</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">pressure</span> <span class="o">=</span> <span class="n">pressure</span></div>


<div class="viewcode-block" id="Epithelium.update_all_max_adhesion_lengths"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.update_all_max_adhesion_lengths">[docs]</a>    <span class="k">def</span> <span class="nf">update_all_max_adhesion_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_length</span><span class="p">,</span> <span class="n">update_adhesion</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the maximum adhesion lengths.  This is the maximum length for force calculation, not prestretch</span>
<span class="sd">        application</span>

<span class="sd">        :param new_length:  New rest length for adhesions.</span>
<span class="sd">        :type new_length: float</span>
<span class="sd">        :param update_adhesion:  (Default value = False)  Whether to refresh the adhesion connection lists.</span>
<span class="sd">        :type update_adhesion: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">max_adhesion_length</span> <span class="o">=</span> <span class="n">new_length</span>

        <span class="k">if</span> <span class="n">update_adhesion</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">()</span></div>


<div class="viewcode-block" id="Epithelium.set_adhesion_type"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_adhesion_type">[docs]</a>    <span class="k">def</span> <span class="nf">set_adhesion_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set how the force for fast adhesions is calculated</span>
<span class="sd">        &quot;meanfield&quot;: update max search length to always find a neighbour, regarless of how far, and calulate the</span>
<span class="sd">        meanfield force.  But the force is set to zero for adhesions longer than max_adhesion_length anyway.</span>
<span class="sd">        &quot;nearest&quot;: Use only the nearest neighbouring node.</span>
<span class="sd">        &quot;fixed_radius&quot;:  Attach to all neighbours within &#39;adhesion_search_radius&#39; and calculate meanfield force.</span>

<span class="sd">        :param new_type:  The rule for calculating adhesion forces.</span>
<span class="sd">        :type new_type: string</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">new_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;meanfield&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;fixed_radius&quot;</span><span class="p">],</span> <span class="s2">&quot;Error, adhesion type </span><span class="si">%s</span><span class="s2"> not valid.&quot;</span> <span class="o">%</span> <span class="n">new_type</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">adhesion_type</span> <span class="o">=</span> <span class="n">new_type</span></div>


<div class="viewcode-block" id="Epithelium.set_fast_adhesion_force_law"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_fast_adhesion_force_law">[docs]</a>    <span class="k">def</span> <span class="nf">set_fast_adhesion_force_law</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constitutive properties of fast adhesions</span>

<span class="sd">        :param new_type:  The new rule for their constitutive properties.</span>
<span class="sd">        :type new_type: string</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">new_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;spring&quot;</span><span class="p">],</span> <span class="s2">&quot;Error, adhesion force law, </span><span class="si">%s</span><span class="s2">, not valid.&quot;</span> <span class="o">%</span> <span class="n">new_type</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">adhesion_force_law</span> <span class="o">=</span> <span class="n">new_type</span></div>


<div class="viewcode-block" id="Epithelium.set_max_num_adhesions_for_fast_force_calculation"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_max_num_adhesions_for_fast_force_calculation">[docs]</a>    <span class="k">def</span> <span class="nf">set_max_num_adhesions_for_fast_force_calculation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_ads</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of adhesions to use when calculating the force for fast adhesions.</span>

<span class="sd">        :param num_ads: The max num adhesions.</span>
<span class="sd">        :type num_ads: int</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">max_num_adhesions_for_force</span> <span class="o">=</span> <span class="n">num_ads</span></div>


<div class="viewcode-block" id="Epithelium.set_adhesion_search_radius"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_adhesion_search_radius">[docs]</a>    <span class="k">def</span> <span class="nf">set_adhesion_search_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the range within which to look for fast adhesion binding pairs. This is used for applying prestretch.</span>
<span class="sd">        For fast adhesion forces, the force is set to zero for lengths above &#39;max_adhesion_length&#39;, such that</span>
<span class="sd">        max_adhesion_length must be &lt;= adhesion_search_radius to work properly</span>
<span class="sd">        It is redundant if adhesion_type=meanfield, which adjusts the value to make sure all are connected.</span>

<span class="sd">        :param radius:  The new search radius.</span>
<span class="sd">        :type num_ads: float</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">adhesion_search_radius</span> <span class="o">=</span> <span class="n">radius</span></div>


<div class="viewcode-block" id="Epithelium.set_constitutive_model"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_constitutive_model">[docs]</a>    <span class="k">def</span> <span class="nf">set_constitutive_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the constitutive model on all the cortices</span>

<span class="sd">        :param model:  The new constitutive model.</span>
<span class="sd">        :type model: string</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">model</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">],</span> <span class="s2">&quot;Error, </span><span class="si">%s</span><span class="s2"> constitutive model is not valid.&quot;</span> <span class="o">%</span> <span class="n">model</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Setting constitutive model to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">model</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">constitutive_model</span> <span class="o">=</span> <span class="n">model</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">possible_constitutive_models</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">]</span></div>


<div class="viewcode-block" id="Epithelium.set_prestrain_type"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_prestrain_type">[docs]</a>    <span class="k">def</span> <span class="nf">set_prestrain_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prestrain_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the way the prestretch is calculated for all cells.</span>

<span class="sd">        :param prestrain_type:  The new prestrain type.</span>
<span class="sd">        :type prestrain_type: string</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">prestrain_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;most_common&quot;</span><span class="p">,</span> <span class="s2">&quot;average&quot;</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">],</span> <span class="s2">&quot;Error self.prestrain_type &quot;</span> \
                                                                <span class="s2">&quot;not in [most_common, average, min, nearest].&quot;</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_type</span> <span class="o">=</span> <span class="n">prestrain_type</span></div>


<div class="viewcode-block" id="Epithelium.set_pressure_on_off"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_pressure_on_off">[docs]</a>    <span class="k">def</span> <span class="nf">set_pressure_on_off</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on_off</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Turn bulk pressure force on or off in the cells.</span>

<span class="sd">        :param on_off:  Control whether to use medial terms.</span>
<span class="sd">        :type on_off: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">pressure_on_off</span> <span class="o">=</span> <span class="n">on_off</span></div>


<div class="viewcode-block" id="Epithelium.set_area_stiffness"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_area_stiffness">[docs]</a>    <span class="k">def</span> <span class="nf">set_area_stiffness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stiffness</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set area stiffness.</span>

<span class="sd">        :param stiffness:  The new bulk stiffness.</span>
<span class="sd">        :type stiffness: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">area_stiffness</span> <span class="o">=</span> <span class="n">stiffness</span></div>


<div class="viewcode-block" id="Epithelium.set_relax_tolerance_for_cells"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_relax_tolerance_for_cells">[docs]</a>    <span class="k">def</span> <span class="nf">set_relax_tolerance_for_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tolerance for getting the tissue to elastic quilibrium</span>

<span class="sd">        :param tol:  New relax tolerance.</span>
<span class="sd">        :type tol: float</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">relax_tol</span> <span class="o">=</span> <span class="n">tol</span></div>


<div class="viewcode-block" id="Epithelium.scale_cells_to_fit_adhesion_to_delta"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.scale_cells_to_fit_adhesion_to_delta">[docs]</a>    <span class="k">def</span> <span class="nf">scale_cells_to_fit_adhesion_to_delta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scale all cells such that their adhesions are within delta apart</span>
<span class="sd">        Note, we do them in sequence, rather than parallel, so no cells end up overlapping</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Scaling cells to fit min adhesion spacing to delta&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Choose the largest (length) cell to start.</span>
        <span class="n">cell_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span>
        <span class="n">area_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">([</span><span class="o">-</span><span class="n">cell</span><span class="o">.</span><span class="n">get_length</span><span class="p">()</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cell_list</span><span class="p">])</span>
        <span class="n">cell_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">area_order</span><span class="p">]</span>
        <span class="c1"># shuffle(cell_list)</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cell_list</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">scale_whole_cell_to_fit_adhesion_to_delta</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">within_hexagons</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">()</span></div>


<div class="viewcode-block" id="Epithelium.hand_of_god_distances_to_delta"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.hand_of_god_distances_to_delta">[docs]</a>    <span class="k">def</span> <span class="nf">hand_of_god_distances_to_delta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_adhesion_update</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Moves any cortices closer than delta away from each other</span>

<span class="sd">        :param initial_adhesion_update:  (Default value = True) Whether to re-calculate the adhesions for all cells</span>
<span class="sd">        :type initial_adhesion_update: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">initial_adhesion_update</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">(</span><span class="n">build_trees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">moved_any</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">this_move</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">move_cortex_nodes_to_equilibrium_dist</span><span class="p">(</span><span class="n">scaling</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">moved_any</span> <span class="o">=</span> <span class="n">this_move</span> <span class="k">if</span> <span class="n">this_move</span> <span class="k">else</span> <span class="n">moved_any</span>
        <span class="k">if</span> <span class="n">moved_any</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">(</span><span class="n">build_trees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Epithelium.set_omega_for_cells"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_omega_for_cells">[docs]</a>    <span class="k">def</span> <span class="nf">set_omega_for_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_omega</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Updates the adhesion strength for specified cells.</span>

<span class="sd">        :param new_omega:  New adhesion strength.</span>
<span class="sd">        :type new_omega: float</span>
<span class="sd">        :param apply_to:  (Default value = &#39;all&#39;)  List of cells to apply function to.</span>
<span class="sd">        :type apply_to: list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">apply_to</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span> <span class="k">if</span> <span class="n">apply_to</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="k">else</span> <span class="n">apply_to</span>

        <span class="k">for</span> <span class="n">cell_ref</span> <span class="ow">in</span> <span class="n">apply_to</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_ref</span><span class="p">]</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">new_omega</span></div>

<div class="viewcode-block" id="Epithelium.apply_prestretch_to_whole_cells"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.apply_prestretch_to_whole_cells">[docs]</a>    <span class="k">def</span> <span class="nf">apply_prestretch_to_whole_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prestretch</span><span class="p">,</span> <span class="n">cells</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a prestretch to the whole cortex of specified cells.</span>

<span class="sd">        :param prestretch:  Magnitude of of prestretch.</span>
<span class="sd">        :type prestretch: float</span>
<span class="sd">        :param cells:  List of cell identities that this will be applied to.</span>
<span class="sd">        :type cells: list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell_ref</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_ref</span><span class="p">]</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="p">,</span> <span class="n">prestretch</span><span class="p">)</span></div>


<div class="viewcode-block" id="Epithelium.apply_prestretch_to_cell_identity_pairs"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.apply_prestretch_to_cell_identity_pairs">[docs]</a>    <span class="k">def</span> <span class="nf">apply_prestretch_to_cell_identity_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prestretch</span><span class="p">,</span> <span class="n">cell_pair</span><span class="p">,</span> <span class="n">unipolar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add active contractility to cell_pairs that share adhesions.</span>

<span class="sd">        :param prestretch:   Magnitude of prestretch</span>
<span class="sd">        :type prestretch: float</span>
<span class="sd">        :param cell_pair:  A list of two cell identites that will localise contractility on shared junctions e.g. ``[&#39;A&#39;, &#39;B&#39;]```.</span>
<span class="sd">        :type cell_pair: list</span>
<span class="sd">        :param unipolar:  (Default value = False)  Apply on only the first cell.</span>
<span class="sd">        :type unipolar: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="p">[</span><span class="n">cell_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">prestretch</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">unipolar</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="p">[</span><span class="n">cell_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">prestretch</span></div>


<div class="viewcode-block" id="Epithelium.run_simulation_timestep"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.run_simulation_timestep">[docs]</a>    <span class="k">def</span> <span class="nf">run_simulation_timestep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">viscous_cells</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run a full simulation timestep, including viscous length updates and solving to equilibrium.</span>

<span class="sd">        :param apply_to:  (Default value = &#39;all&#39;)  List of cells to apply function to.</span>
<span class="sd">        :type apply_to: list</span>
<span class="sd">        :param viscous_cells:  (Default value = &#39;all&#39;)  List of cells that will have length and area updates.</span>
<span class="sd">        :type apply_to: list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Update adhesions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">(</span><span class="n">apply_to</span><span class="o">=</span><span class="n">apply_to</span><span class="p">)</span>
        <span class="c1"># Update slow adhesions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_slow_adhesions</span><span class="p">(</span><span class="n">prune</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Viscous update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_all_rest_lengths_and_areas</span><span class="p">(</span><span class="n">apply_to</span><span class="o">=</span><span class="n">viscous_cells</span><span class="p">)</span>
        <span class="c1"># Relax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solve_bvps_in_parallel</span><span class="p">(</span><span class="n">applyTo</span><span class="o">=</span><span class="n">apply_to</span><span class="p">)</span></div>


<div class="viewcode-block" id="Epithelium.solve_bvps_in_series"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.solve_bvps_in_series">[docs]</a>    <span class="k">def</span> <span class="nf">solve_bvps_in_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">applyTo</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solve the bvp for each cell in series to reach elastic equilibrium. \todo haven&#39;t tested this functionality</span>
<span class="sd">        in a while</span>

<span class="sd">        :param applyTo:  (Default value = &#39;all&#39;)  Which cells to apply the function to.</span>
<span class="sd">        :type applyTo: list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;Solving BVPs in series on&quot;</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">applyTo</span><span class="p">)]),</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Randomise the order in which we apply the solving</span>
        <span class="n">applyTo</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span> <span class="k">if</span> <span class="n">applyTo</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="k">else</span> <span class="n">applyTo</span>
        <span class="n">shuffle</span><span class="p">(</span><span class="n">applyTo</span><span class="p">)</span>

        <span class="c1"># Update the adhesion points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">(</span><span class="n">build_trees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell_label</span> <span class="ow">in</span> <span class="n">applyTo</span><span class="p">:</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_label</span><span class="p">]</span>
            <span class="c1"># cell.move_cortex_nodes_to_equilibrium_dist(scaling=1)</span>

            <span class="n">cell</span><span class="o">.</span><span class="n">solve_bvp</span><span class="p">()</span>

            <span class="c1"># Get the neighbour cells</span>
            <span class="n">naboer</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_neighbours</span><span class="p">()</span>
            <span class="n">naboer</span> <span class="o">=</span> <span class="p">[</span><span class="n">nabo</span> <span class="k">for</span> <span class="n">nabo</span> <span class="ow">in</span> <span class="n">naboer</span> <span class="k">if</span> <span class="n">nabo</span> <span class="o">!=</span> <span class="s1">&#39;boundary&#39;</span><span class="p">]</span>
            <span class="n">naboer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>

            <span class="c1"># Update the adhesion points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">(</span><span class="n">build_trees</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="n">naboer</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">total_elastic_relaxes</span> <span class="o">+=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="Epithelium.solve_bvps_in_parallel"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.solve_bvps_in_parallel">[docs]</a>    <span class="k">def</span> <span class="nf">solve_bvps_in_parallel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">applyTo</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">hand_of_god</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Use joblib to solve the bvp for all cortices and reach tissue elastic equilibrium</span>

<span class="sd">        :param applyTo:  (Default value = &quot;all&quot;)  Which cells to apply the function to.</span>
<span class="sd">        :type applyTo: list</span>
<span class="sd">        :param smoothing:  (Default value = 0)  How much to smooth cortex variables between solving.</span>
<span class="sd">        :type smoothing: float</span>
<span class="sd">        :param hand_of_god:  (Default value = True)  Whether to manually move cortices to at least ``delta`` apart before solving.  This helps with stability.</span>
<span class="sd">        :type hand_of_god: bool</span>
<span class="sd">        :return success: Whether solving ran without errors and converged.</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;Solving BVPs in parallel on cells&quot;</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">applyTo</span><span class="p">)]),</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Which cells will relax</span>
        <span class="n">applyTo</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span> <span class="k">if</span> <span class="n">applyTo</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="k">else</span> <span class="n">applyTo</span>
        <span class="n">cells_to_relax</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">applyTo</span><span class="p">]</span>

        <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># This will only pass when the number of nodes has stayed constant.</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Returns this bools as a check of whether we were successful within max_relaxes</span>

        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>

            <span class="c1"># Get old positions before we do anything</span>
            <span class="n">old_xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells_to_relax</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)])</span>
            <span class="n">old_ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells_to_relax</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">)])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">(</span><span class="n">only_fast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">build_trees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_bc</span> <span class="o">!=</span> <span class="s1">&#39;fixed&#39;</span><span class="p">:</span>
                <span class="n">boundary_success</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relax_deformable_boundary</span><span class="p">(</span><span class="n">update_adhesions</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">(</span><span class="n">only_fast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">build_trees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">boundary_success</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Fix min distances to delta</span>
            <span class="k">if</span> <span class="n">hand_of_god</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hand_of_god_distances_to_delta</span><span class="p">(</span><span class="n">initial_adhesion_update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Run solver in parallel</span>
            <span class="n">solve_data</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">solve_bvp</span><span class="p">)()</span>
                                             <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells_to_relax</span><span class="p">)</span>
            <span class="n">sols_fail_check</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">solve_data</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_solve_success</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">sols_fail_check</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">solve_data</span><span class="p">])</span>

            <span class="c1"># Check if we are moving too far.</span>
            <span class="c1"># Calculate the distances that the cortex has moved.</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">results</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">-</span> <span class="n">old_xs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">results</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">-</span> <span class="n">old_ys</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">max_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="n">dist_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span>
            <span class="c1"># If any part of the cortex moved too far, slow it down.</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">relax_dist_threshold</span>

            <span class="c1"># If we moved too far AND failed then retry. If we failed but didn&#39;t move much then just let it pass</span>
            <span class="k">if</span> <span class="n">max_dist</span> <span class="o">&gt;</span> <span class="n">cutoff</span> <span class="ow">and</span> <span class="n">sols_fail_check</span><span class="p">:</span>

                <span class="c1"># Make sure we loop again</span>
                <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Moved too far (</span><span class="si">%s</span><span class="s1">); decreasing step. sols_fail_check = </span><span class="si">%s</span><span class="s1"> (max </span><span class="si">%s</span><span class="s1">). Num tries = </span><span class="si">%s</span><span class="s1">&#39;</span>
                          <span class="o">%</span> <span class="p">(</span><span class="n">max_dist</span><span class="p">,</span> <span class="n">sols_fail_check</span><span class="p">,</span> <span class="nb">max</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">solve_data</span><span class="p">]),</span> <span class="n">counter</span><span class="p">))</span>

                <span class="c1"># Get the old variables</span>
                <span class="n">old_vars</span> <span class="o">=</span> <span class="p">[[</span><span class="n">cell</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
                             <span class="n">cell</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">C</span><span class="p">]</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span>
                <span class="n">old_vars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">old_vars</span><span class="p">)</span>

                <span class="c1"># update the results to not move as far.</span>
                <span class="n">ratio_to_scale</span> <span class="o">=</span> <span class="n">cutoff</span> <span class="o">/</span> <span class="n">max_dist</span>
                <span class="n">total_change</span> <span class="o">=</span> <span class="n">results</span> <span class="o">-</span> <span class="n">old_vars</span>
                <span class="n">results</span> <span class="o">=</span> <span class="n">old_vars</span> <span class="o">+</span> <span class="n">ratio_to_scale</span> <span class="o">*</span> <span class="n">total_change</span>

                <span class="c1"># Update the solving tolerance</span>
                <span class="n">sol_status_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">solve_data</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Solving failed: </span><span class="si">{</span><span class="n">sol_status_list</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="c1"># Update the relaxation tolerance to a softer value for the solver</span>
                <span class="k">for</span> <span class="n">cell_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sol_status_list</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">sol_status_list</span><span class="p">[</span><span class="n">cell_index</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="n">cell_index</span><span class="p">]</span><span class="o">.</span><span class="n">relax_tol</span> <span class="o">*=</span> <span class="mi">2</span>

            <span class="c1"># Or if we haven&#39;t reached elastic equilibrium (no more movement) relax again</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">dist_norm</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_relax_tol</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">boundary_success</span><span class="p">)</span> <span class="ow">and</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_elastic_relax_steps</span><span class="p">:</span>
                <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># if self.verbose:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Not yet in equilibrium (d_norm = </span><span class="si">%s</span><span class="s1">). Have relaxed </span><span class="si">%s</span><span class="s1"> times&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dist_norm</span><span class="p">,</span> <span class="n">counter</span><span class="p">))</span>

            <span class="c1"># Or, if passed all checks, we are done.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">sols_fail_check</span> <span class="k">else</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">in_equilibrium</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># If we have relaxed too many times, break out</span>
            <span class="k">if</span> <span class="n">counter</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_elastic_relax_steps</span><span class="p">:</span>
                <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">in_equilibrium</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Relaxed more than max_elastic_relax_steps; ending now.&#39;</span><span class="p">)</span>

            <span class="c1"># Update the cortex variables</span>
            <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cells_to_relax</span><span class="p">)):</span>
                <span class="n">cells_to_relax</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">cell_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">cells_to_relax</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">cell_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">cells_to_relax</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">cell_id</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">cells_to_relax</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">cell_id</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">cells_to_relax</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">cell_id</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
                <span class="n">cells_to_relax</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">cell_id</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
                <span class="n">cells_to_relax</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">cell_id</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
                <span class="n">cells_to_relax</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">cells_to_relax</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span>

            <span class="k">if</span> <span class="n">smoothing</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">smooth_all_variables_with_spline</span><span class="p">(</span><span class="n">smoothing</span><span class="o">=</span><span class="n">smoothing</span><span class="p">)</span>

            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">last_num_internal_relaxes</span> <span class="o">=</span> <span class="n">counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_elastic_relaxes</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">success</span></div>


<div class="viewcode-block" id="Epithelium.get_unbalanced_force_residual"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_unbalanced_force_residual">[docs]</a>    <span class="k">def</span> <span class="nf">get_unbalanced_force_residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;L2&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the unbalanced force at centre of every bicellular junction.</span>
<span class="sd">        Can take L1 or L2 norm.</span>

<span class="sd">        :param norm:  (Default value = &#39;L2&#39;)</span>
<span class="sd">        :type norm: string</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Need to implement force calculation in unbalanced residual&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">norm</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;L1&#39;</span><span class="p">,</span> <span class="s1">&#39;L2&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">],</span> <span class="s2">&quot;Error, norm must be L1 or L2 or max&quot;</span>

        <span class="c1"># Get cell pairs sharing juncs</span>
        <span class="n">junc_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_junction_cell_pairs</span><span class="p">()</span>

        <span class="c1"># Loop over each and get force</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell_pair</span> <span class="ow">in</span> <span class="n">junc_pairs</span><span class="p">:</span>
            <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="c1"># Get midpoint</span>
            <span class="n">c1_idx</span><span class="p">,</span> <span class="n">c2_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates_of_junction_midpoint</span><span class="p">(</span><span class="n">cell_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cell_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># If not connected:</span>
            <span class="k">if</span> <span class="n">c1_idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">c2_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Get normal force</span>
            <span class="n">diffs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ixd_shift</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="n">shifted_idx1</span> <span class="o">=</span> <span class="n">c1_idx</span> <span class="o">+</span> <span class="n">ixd_shift</span>
                <span class="n">shifted_idx2</span> <span class="o">=</span> <span class="n">c2_idx</span> <span class="o">+</span> <span class="n">ixd_shift</span>
                <span class="n">shifted_idx1</span> <span class="o">=</span> <span class="n">shifted_idx1</span> <span class="k">if</span> <span class="n">shifted_idx1</span> <span class="o">&lt;</span> <span class="n">c1</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="n">shifted_idx1</span> <span class="o">-</span> <span class="n">c1</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">size</span>
                <span class="n">shifted_idx2</span> <span class="o">=</span> <span class="n">shifted_idx2</span> <span class="k">if</span> <span class="n">shifted_idx2</span> <span class="o">&lt;</span> <span class="n">c2</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="n">shifted_idx2</span> <span class="o">-</span> <span class="n">c2</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">size</span>

                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Need to implement force calculation in unbalanced residual&quot;</span><span class="p">)</span>

                <span class="c1"># ctau_1 = c1.kappa * c1.C[shifted_idx1] ** 3 + \</span>
                <span class="c1">#          (1 - (c1.get_prestrains()[shifted_idx1] / c1.gamma[shifted_idx1])) * c1.C[shifted_idx1]</span>
                <span class="c1"># ctau_1 /= c1.kappa</span>
                <span class="c1"># # For other cell</span>
                <span class="c1"># ctau_2 = c2.kappa * c2.C[shifted_idx2] ** 3 + \</span>
                <span class="c1">#          (1 - (c2.get_prestrains()[shifted_idx2] / c2.gamma[shifted_idx2])) * c2.C[shifted_idx2]</span>
                <span class="c1"># ctau_2 /= c2.kappa</span>
                <span class="c1">#</span>
                <span class="c1"># diffs.append(ctau_1 - ctau_2)</span>

            <span class="c1"># Store mean</span>
            <span class="n">residuals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diffs</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;L1&#39;</span><span class="p">:</span>
            <span class="n">total_residual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;L2&#39;</span><span class="p">:</span>
            <span class="n">total_residual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
            <span class="n">total_residual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">residuals</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">total_residual</span></div>


<div class="viewcode-block" id="Epithelium.get_junction_cell_pairs"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_junction_cell_pairs">[docs]</a>    <span class="k">def</span> <span class="nf">get_junction_cell_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a set of the pairs of cells belonging to a junction, i.e. [(c1, c2),...], for all bicellular</span>
<span class="sd">        junctions in the tissue.</span>

<span class="sd">        :return junc_pairs:  A list of the bicellualr junctions in the tissue.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cell_ref_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span>
        <span class="n">junc_pairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cell_ref</span> <span class="ow">in</span> <span class="n">cell_ref_list</span><span class="p">:</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_ref</span><span class="p">]</span>

            <span class="c1"># Get cell neighbours</span>
            <span class="n">cell_junc_pairs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="p">([</span><span class="n">cell_ref</span><span class="p">,</span> <span class="n">nabo</span><span class="p">])</span>
                               <span class="k">for</span> <span class="n">nabo</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">adhesion_connections_identities</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">])</span>
                               <span class="k">if</span> <span class="n">nabo</span> <span class="ow">in</span> <span class="n">cell_ref_list</span><span class="p">]</span>

            <span class="c1"># Update the global list</span>
            <span class="n">junc_pairs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell_junc_pairs</span><span class="p">)</span>

        <span class="c1"># Store the pairs as lists</span>
        <span class="n">junc_pairs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">junc_pairs</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">junc_pairs</span></div>


<div class="viewcode-block" id="Epithelium.get_xy_segment_lengths"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_xy_segment_lengths">[docs]</a>    <span class="k">def</span> <span class="nf">get_xy_segment_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the spacing between nodes on a curve specified by (array(x), array(y))</span>

<span class="sd">        :param x:  The x-coords of the nodes</span>
<span class="sd">        :type x: np.array</span>
<span class="sd">        :param y:  The y-coords of the nodes</span>
<span class="sd">        :type y: np.array</span>
<span class="sd">        :return spacing:  The spacing.</span>
<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">spacing</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spacing</span></div>


<div class="viewcode-block" id="Epithelium.get_shortest_distance_between_two_cells"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_shortest_distance_between_two_cells">[docs]</a>    <span class="k">def</span> <span class="nf">get_shortest_distance_between_two_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the shortest distance between two cells. This is a proxy for the length of</span>
<span class="sd">        the shrinking junction when cell_1_ref = &quot;C&quot; and cell_2_ref = &quot;D&quot;</span>

<span class="sd">        :param cell_1_ref: Reference of first cell id.</span>
<span class="sd">        :type cell_1_ref: string</span>
<span class="sd">        :param cell_2_ref: Reference of first cell id.</span>
<span class="sd">        :type cell_2_ref: string</span>
<span class="sd">        :return min_dist:  The distance between the cortices.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cell_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_1_ref</span><span class="p">]</span>
        <span class="n">cell_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_2_ref</span><span class="p">]</span>

        <span class="c1"># Get coords.</span>
        <span class="n">cell_1_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">cell_1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cell_1</span><span class="o">.</span><span class="n">y</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cell_2_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">cell_2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cell_2</span><span class="o">.</span><span class="n">y</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Get shortest distance</span>
        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">cell_1_coords</span><span class="p">,</span> <span class="n">cell_2_coords</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">min_dist</span></div>


<div class="viewcode-block" id="Epithelium.get_coordinates_of_nearest_points_between_cells"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_coordinates_of_nearest_points_between_cells">[docs]</a>    <span class="k">def</span> <span class="nf">get_coordinates_of_nearest_points_between_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the local idxs for the nearest points between two cell cortices</span>

<span class="sd">        :param cell_1_ref:  Identity of one cell.</span>
<span class="sd">        :type cell_1_ref: string</span>
<span class="sd">        :param cell_2_ref:  Identity of another cell.</span>
<span class="sd">        :type cell_2_ref: string</span>
<span class="sd">        :return coords: Local indices of cells where the distance between them is minimised.</span>
<span class="sd">        :rtype: (int, int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cell_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_1_ref</span><span class="p">]</span>
        <span class="n">cell_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_2_ref</span><span class="p">]</span>

        <span class="c1"># Get coords.</span>
        <span class="n">cell_1_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">cell_1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cell_1</span><span class="o">.</span><span class="n">y</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cell_2_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">cell_2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cell_2</span><span class="o">.</span><span class="n">y</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Get shortest distance</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">cell_1_coords</span><span class="p">,</span> <span class="n">cell_2_coords</span><span class="p">)</span>

        <span class="c1"># Return (idx of Cell1, idx of Cell2)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),</span> <span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="Epithelium.get_bicellular_junctions_for_cell"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_bicellular_junctions_for_cell">[docs]</a>    <span class="k">def</span> <span class="nf">get_bicellular_junctions_for_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_ref</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">d_threshold</span><span class="o">=</span><span class="mf">0.015</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the local indices (i,j) for the coordinates of the endpoints of bicellular junctions in a cell</span>

<span class="sd">        :param cell_ref: identity of cell.</span>
<span class="sd">        :type cell_ref: string</span>
<span class="sd">        :param smooth:  (Default value = True)  Whether to smooth the cortex curvature to find the straight segments.</span>
<span class="sd">        :type smooth: bool</span>
<span class="sd">        :param d_threshold:  (Default value = 0.015)  Threshold below which cortex is classed as stright.</span>
<span class="sd">        :type d_threshold: float</span>
<span class="sd">        :return bi_junctions:  (list([id1, id2],...))  A list of the paired local ids for where the bicellular junctions start and end.</span>
<span class="sd">        :rtype: string</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_ref</span><span class="p">]</span>
        <span class="n">filtered_d</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">D</span>
        <span class="k">if</span> <span class="n">smooth</span><span class="p">:</span>
            <span class="n">filtered_d</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span><span class="n">filtered_d</span><span class="p">,</span> <span class="mi">81</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># Find where curvature gradient is small</span>
        <span class="n">idxs_to_plot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">filtered_d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">d_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Remove small consective groups of indices, which may be at the vertex centre</span>
        <span class="n">consec_groups</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">consecutive_groups</span><span class="p">(</span><span class="n">idxs_to_plot</span><span class="p">)]</span>
        <span class="n">idxs_to_plot</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">subgroup</span> <span class="ow">in</span> <span class="n">consec_groups</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">subgroup</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subgroup</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">25</span><span class="p">]</span>

        <span class="c1"># Find the vertices, then get the points closest to the vertex.</span>
        <span class="n">most_ads_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">ad_ids</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="n">ad_ids</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">)</span> <span class="k">if</span> <span class="n">ad_ids</span> <span class="k">else</span> <span class="mi">0</span>
                               <span class="k">for</span> <span class="n">ad_ids</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">])</span>
        <span class="n">vertex_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">most_ads_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">most_ads_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">bicellular_ends</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v_loc</span> <span class="ow">in</span> <span class="n">vertex_locs</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">idxs_to_plot</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">idxs_to_plot</span> <span class="o">&gt;</span> <span class="n">v_loc</span><span class="p">)],</span> <span class="n">idxs_to_plot</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">idxs_to_plot</span> <span class="o">&gt;</span> <span class="n">v_loc</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">v1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bicellular_ends</span><span class="p">:</span>
                    <span class="n">bicellular_ends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">v2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bicellular_ends</span><span class="p">:</span>
                    <span class="n">bicellular_ends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="n">bicellular_juncs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bicellular_ends</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bicellular_juncs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span><span class="p">,</span> <span class="n">bicellular_ends</span><span class="p">[(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">bicellular_ends</span><span class="p">)]))</span>
        <span class="c1"># bicellular_juncs = [(bicellular_ends[i], bicellular_ends[i+1]) for i in range(len(bicellular_ends))[::2]]</span>

        <span class="k">return</span> <span class="n">bicellular_juncs</span></div>


<div class="viewcode-block" id="Epithelium.check_if_cells_share_a_vertex"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.check_if_cells_share_a_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">check_if_cells_share_a_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c1_ref</span><span class="p">,</span> <span class="n">c2_ref</span><span class="p">,</span> <span class="n">c3_ref</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if each cell shares adehsions with both other cells.  Doesn&#39;t work for the tissue boundary</span>

<span class="sd">        :param c1_ref:  Identifier for first cell</span>
<span class="sd">        :type c1_ref: string</span>
<span class="sd">        :param c2_ref:  Identifier for second cell</span>
<span class="sd">        :type c2_ref: string</span>
<span class="sd">        :param c3_ref:  Identifier for third cell</span>
<span class="sd">        :type c3_ref: string</span>
<span class="sd">        :return vertex_check:  True if cells share a vertex</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;boundary&#39;</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c1_ref</span><span class="p">,</span> <span class="n">c2_ref</span><span class="p">,</span> <span class="n">c3_ref</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">c2_ref</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">c1_ref</span><span class="p">]</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">))</span> <span class="ow">and</span>
                <span class="n">c3_ref</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">c1_ref</span><span class="p">]</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">))</span> <span class="ow">and</span>
                <span class="n">c3_ref</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">c2_ref</span><span class="p">]</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">)))</span></div>


<div class="viewcode-block" id="Epithelium.get_locations_of_cortex_adhesion_transition"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_locations_of_cortex_adhesion_transition">[docs]</a>    <span class="k">def</span> <span class="nf">get_locations_of_cortex_adhesion_transition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">vertex_neighbours</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find where cell 1 (cell_1_ref) swaps from adhering to cell 2 to cell 3.</span>
<span class="sd">        vertex_neighbours = (cell_2_ref, cell_3_ref)</span>

<span class="sd">        :param cell_1_ref:  Identity of cell 1.</span>
<span class="sd">        :type cell_1_ref: string</span>
<span class="sd">        :param vertex_neighbours:  List (len=2) of neighbour identities.</span>
<span class="sd">        :type vertex_neighbours: list</span>
<span class="sd">        :return local_index:  Local idx in cell 1 where there is an adhesion transition.</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cell_2_ref</span> <span class="o">=</span> <span class="n">vertex_neighbours</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cell_3_ref</span> <span class="o">=</span> <span class="n">vertex_neighbours</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">cell_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_1_ref</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_if_cells_share_a_vertex</span><span class="p">(</span><span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">,</span> <span class="n">cell_3_ref</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cells </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2"> don&#39;t share a vertex&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">,</span> <span class="n">cell_3_ref</span><span class="p">))</span>

            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Find most adhesion connections for 1</span>
        <span class="n">most_ads_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">ad_ids</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="n">ad_ids</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">)</span> <span class="k">if</span> <span class="n">ad_ids</span> <span class="k">else</span> <span class="mi">0</span>
                               <span class="k">for</span> <span class="n">ad_ids</span> <span class="ow">in</span> <span class="n">cell_1</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">])</span>
        <span class="n">changing_indices_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">most_ads_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">most_ads_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">changing_indices_23</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">changing_indices_1</span> <span class="k">if</span> <span class="n">most_ads_1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cell_2_ref</span><span class="p">,</span> <span class="n">cell_3_ref</span><span class="p">]</span>
                              <span class="ow">and</span> <span class="n">most_ads_1</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cell_2_ref</span><span class="p">,</span> <span class="n">cell_3_ref</span><span class="p">]]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">changing_indices_23</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error, vertex not well defined. Trying cortex with no adhesion&#39;</span><span class="p">)</span>

            <span class="c1"># Get the open bit</span>
            <span class="n">changing_indices_none</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">changing_indices_1</span> <span class="k">if</span> <span class="n">most_ads_1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                                     <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">,</span> <span class="n">cell_3_ref</span><span class="p">]</span> <span class="ow">and</span> <span class="n">most_ads_1</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                                     <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">,</span> <span class="n">cell_3_ref</span><span class="p">]]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">changing_indices_none</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error, failed no adhesion cortex&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span>

            <span class="n">midpoint</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">changing_indices_none</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">midpoint</span>

        <span class="k">return</span> <span class="n">changing_indices_23</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="Epithelium.get_all_vertices_for_cell"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_all_vertices_for_cell">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_vertices_for_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_ref</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  Get a list of identities of neighbours that a cell shares adhesions with.</span>

<span class="sd">        :param cell_ref:  Identity of cell.</span>
<span class="sd">        :type cell_ref: string</span>
<span class="sd">        :return vertices:  List of neighbour identities.</span>
<span class="sd">        :rtype: list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_ref</span><span class="p">]</span>
        <span class="c1"># Get neighbours</span>
        <span class="n">cell_neighbours</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">cell</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">))</span>
        <span class="c1"># Possible vertices</span>
        <span class="n">possible_verts</span> <span class="o">=</span> <span class="p">[[</span><span class="n">cell_ref</span><span class="p">,</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">cell_neighbours</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="c1"># Get real ones</span>
        <span class="n">cell_vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">possible_verts</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_if_cells_share_a_vertex</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">cell_vertices</span></div>


<div class="viewcode-block" id="Epithelium.get_all_tissue_vertices"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_all_tissue_vertices">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_tissue_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a set of all unique vertices (as lists of 3 cell identities) in the tissue</span>

<span class="sd">        :param apply_to:  (Default value = &#39;all&#39;)  If not ``&#39;all&#39;``, a list of cell identifiers that the function will be applied to.</span>
<span class="sd">        :type apply_to: string</span>
<span class="sd">        :return vertices:  A list of triplets of cell identities.</span>
<span class="sd">        :rtype: list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">apply_to</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span> <span class="k">if</span> <span class="n">apply_to</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="k">else</span> <span class="n">apply_to</span>

        <span class="n">vertices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">apply_to</span><span class="p">:</span>
            <span class="n">cell_verts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all_vertices_for_cell</span><span class="p">(</span><span class="n">ref</span><span class="p">)]</span>
            <span class="n">vertices</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell_verts</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">vert</span><span class="p">)</span> <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">]</span></div>

<div class="viewcode-block" id="Epithelium.get_cortex_coord_of_vertex_triangle"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_cortex_coord_of_vertex_triangle">[docs]</a>    <span class="k">def</span> <span class="nf">get_cortex_coord_of_vertex_triangle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">,</span> <span class="n">cell_3_ref</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get local index for the coords of the vertex triangle on three cells.</span>

<span class="sd">        :param cell_1_ref:   Idientifier of first cell.</span>
<span class="sd">        :type cell_1_ref: string</span>
<span class="sd">        :param cell_2_ref:   Idientifier of second cell.</span>
<span class="sd">        :type cell_2_ref: string</span>
<span class="sd">        :param cell_3_ref:   Idientifier of third cell.</span>
<span class="sd">        :type cell_3_ref: string</span>
<span class="sd">        :return vertex:  The three local indices on each cortex, where the vertex is located on each cortex.</span>
<span class="sd">        :rtype: tuple</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coord1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_locations_of_cortex_adhesion_transition</span><span class="p">(</span><span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">vertex_neighbours</span><span class="o">=</span><span class="p">(</span><span class="n">cell_2_ref</span><span class="p">,</span> <span class="n">cell_3_ref</span><span class="p">))</span>
        <span class="n">coord2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_locations_of_cortex_adhesion_transition</span><span class="p">(</span><span class="n">cell_2_ref</span><span class="p">,</span> <span class="n">vertex_neighbours</span><span class="o">=</span><span class="p">(</span><span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">cell_3_ref</span><span class="p">))</span>
        <span class="n">coord3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_locations_of_cortex_adhesion_transition</span><span class="p">(</span><span class="n">cell_3_ref</span><span class="p">,</span> <span class="n">vertex_neighbours</span><span class="o">=</span><span class="p">(</span><span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">,</span> <span class="n">coord3</span></div>


<div class="viewcode-block" id="Epithelium.get_cartesian_coords_of_vertex_triangle"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_cartesian_coords_of_vertex_triangle">[docs]</a>    <span class="k">def</span> <span class="nf">get_cartesian_coords_of_vertex_triangle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">,</span> <span class="n">cell_3_ref</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get cartesian coords of the vertex traingle from the local idxs</span>

<span class="sd">        :param cell_1_ref:  Idientifier of first cell.</span>
<span class="sd">        :type cell_1_ref: string</span>
<span class="sd">        :param cell_2_ref:  Idientifier of second cell.</span>
<span class="sd">        :type cell_2_ref: string</span>
<span class="sd">        :param cell_3_ref:  Idientifier of third cell.</span>
<span class="sd">        :type cell_3_ref: string</span>
<span class="sd">        :return vertex:  The ((x1,y1), (x2,y2), (x3,y3)) cartesian coords of the triangle.</span>
<span class="sd">        :rtype: tuple</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">,</span> <span class="n">coord3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cortex_coord_of_vertex_triangle</span><span class="p">(</span><span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">,</span> <span class="n">cell_3_ref</span><span class="p">)</span>

        <span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_1_ref</span><span class="p">]</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_2_ref</span><span class="p">]</span>
        <span class="n">c3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_3_ref</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">c1</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">coord1</span><span class="p">],</span> <span class="n">c1</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">coord1</span><span class="p">]),</span> <span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">coord2</span><span class="p">],</span> <span class="n">c2</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">coord2</span><span class="p">]),</span> <span class="p">(</span><span class="n">c3</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">coord3</span><span class="p">],</span> <span class="n">c3</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">coord3</span><span class="p">])</span></div>


<div class="viewcode-block" id="Epithelium.get_vertex_circumcircle"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_vertex_circumcircle">[docs]</a>    <span class="k">def</span> <span class="nf">get_vertex_circumcircle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">,</span> <span class="n">cell_3_ref</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get centroid and radius of circumcircle\insribed at vertices</span>

<span class="sd">        :param cell_1_ref:  Idientifier of first cell.</span>
<span class="sd">        :type cell_1_ref: string</span>
<span class="sd">        :param cell_2_ref:  Idientifier of second cell.</span>
<span class="sd">        :type cell_3_ref: string</span>
<span class="sd">        :param cell_3_ref:  Idientifier of third cell.</span>
<span class="sd">        :type cell_3_ref: string</span>
<span class="sd">        :return circle_props:  The (x,y) centre and radius of the circumcircle.</span>
<span class="sd">        :rtype: tuple</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cartesian_coords_of_vertex_triangle</span><span class="p">(</span><span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">,</span> <span class="n">cell_3_ref</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">),</span> <span class="p">(</span><span class="n">x3</span><span class="p">,</span> <span class="n">y3</span><span class="p">)</span> <span class="o">=</span> <span class="n">T</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x3</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y3</span> <span class="o">-</span> <span class="n">y1</span><span class="p">],</span> <span class="p">[</span><span class="n">x3</span> <span class="o">-</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y3</span> <span class="o">-</span> <span class="n">y2</span><span class="p">]])</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">x3</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y3</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">x1</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">y1</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">x3</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y3</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">x2</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">y2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">Ainv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ainv</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">r</span></div>


<div class="viewcode-block" id="Epithelium.get_length_of_shared_junction"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_length_of_shared_junction">[docs]</a>    <span class="k">def</span> <span class="nf">get_length_of_shared_junction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">,</span> <span class="n">alternative_junc_refs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the length of the bijunction shared between two cells</span>

<span class="sd">        :param cell_1_ref:  Idientifier of first cell.</span>
<span class="sd">        :type cell_1_ref: string</span>
<span class="sd">        :param cell_2_ref:  Idientifier of second cell.</span>
<span class="sd">        :type cell_2_ref: string</span>
<span class="sd">        :param alternative_junc_refs:  (Default value = None)  Possible alternative junctions to try. Passed as [[&#39;ref_1&#39;, &#39;ref_2&#39;],...]</span>
<span class="sd">        :type alternative_junc_refs: list</span>
<span class="sd">        :return length:  The length of cortex where the two cells share adhesions.  Returns 0 if they don&#39;t share any.</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cell_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_1_ref</span><span class="p">]</span>
        <span class="n">cell_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_2_ref</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">cell_1_ref</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">cell_2</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">))</span> <span class="ow">or</span>
                <span class="n">cell_2_ref</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">cell_1</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">))):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cells </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2"> don&#39;t share a junction&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">alternative_junc_refs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Now trying alternatives </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">alternative_junc_refs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alternative_junc_refs</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_length_of_shared_junction</span><span class="p">(</span><span class="n">cell_1_ref</span><span class="o">=</span><span class="n">alternative_junc_refs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                   <span class="n">cell_2_ref</span><span class="o">=</span><span class="n">alternative_junc_refs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">length</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Boolean where connected</span>
        <span class="n">shared_junc_bool_1</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell_2_ref</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">ad_ids</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="n">ad_ids</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">)</span> <span class="k">if</span> <span class="n">ad_ids</span> <span class="k">else</span> <span class="mi">0</span>
                              <span class="k">for</span> <span class="n">ad_ids</span> <span class="ow">in</span> <span class="n">cell_1</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">]</span>

        <span class="c1"># Rare case where there is a connection only on one side.</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">shared_junc_bool_1</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error, cells </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2"> don&#39;t share a junction&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">))</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Get the segment lengths of cortex 1</span>
        <span class="n">seg_lengths</span> <span class="o">=</span> <span class="n">cell_1</span><span class="o">.</span><span class="n">get_xy_segment_lengths</span><span class="p">()</span>

        <span class="c1"># Get the total distance of the segment lengths</span>
        <span class="n">total_length</span> <span class="o">=</span> <span class="n">seg_lengths</span><span class="p">[</span><span class="n">shared_junc_bool_1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">total_length</span></div>


<div class="viewcode-block" id="Epithelium.get_coordinates_of_junction_midpoint"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_coordinates_of_junction_midpoint">[docs]</a>    <span class="k">def</span> <span class="nf">get_coordinates_of_junction_midpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the local idx midpoint of the junction shared between two cells</span>

<span class="sd">        :param cell_1_ref:  Idientifier of first cell.</span>
<span class="sd">        :type cell_1_ref: string</span>
<span class="sd">        :param cell_2_ref:  Idientifier of second cell.</span>
<span class="sd">        :type cell_2_ref: string</span>
<span class="sd">        :return midpoint:  the local indices in each cell (idx_c1, idx_c2) of the junction midpoint</span>
<span class="sd">        :rtype: (int, int)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cell_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_1_ref</span><span class="p">]</span>
        <span class="n">cell_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_2_ref</span><span class="p">]</span>

        <span class="k">assert</span> <span class="p">(</span><span class="n">cell_1_ref</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">cell_2</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">))</span> <span class="ow">or</span>
                <span class="n">cell_2_ref</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">cell_1</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">))),</span> \
                <span class="s2">&quot;Error, cells </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2"> don&#39;t share a junction&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cell_1_ref</span><span class="p">,</span> <span class="n">cell_2_ref</span><span class="p">)</span>

        <span class="c1"># Boolean where connected</span>
        <span class="n">shared_junc_bool_1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">cell_2_ref</span> <span class="ow">in</span> <span class="n">ad_list</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">ad_list</span> <span class="ow">in</span> <span class="n">cell_1</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">]</span>
        <span class="c1"># Rare case where there is a connection only on one side.</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">shared_junc_bool_1</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># If the indices start from the end of the list and run over, we need to roll it</span>
        <span class="n">idx_to_roll</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shared_junc_bool_1</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">idx_to_roll</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shared_junc_bool_1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">shared_junc_bool_1</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">shared_junc_bool_1</span><span class="p">)</span>
            <span class="n">shared_junc_bool_1</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shared_junc_bool_1</span><span class="p">)</span> <span class="o">-</span> <span class="n">idx_to_roll</span><span class="p">)</span>

        <span class="c1"># get midpoint</span>
        <span class="n">mid_point_1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">shared_junc_bool_1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="c1"># Unroll it if we had to.</span>
        <span class="k">if</span> <span class="n">idx_to_roll</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shared_junc_bool_1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mid_point_1</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shared_junc_bool_1</span><span class="p">)</span> <span class="o">-</span> <span class="n">idx_to_roll</span>
        <span class="n">mid_point_1_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cell_1</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">mid_point_1</span><span class="p">],</span> <span class="n">cell_1</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">mid_point_1</span><span class="p">]]])</span>

        <span class="c1"># Point closest on other cortex</span>
        <span class="n">cell_2_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">cell_2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cell_2</span><span class="o">.</span><span class="n">y</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">mid_point_1_coords</span><span class="p">,</span> <span class="n">cell_2_coords</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mid_point_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mid_point_1</span><span class="p">,</span> <span class="n">mid_point_2</span></div>


<div class="viewcode-block" id="Epithelium.get_cell_sum_stress_tensor"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_cell_sum_stress_tensor">[docs]</a>    <span class="k">def</span> <span class="nf">get_cell_sum_stress_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The sum of all cell stress tensors.</span>

<span class="sd">        :return stress:  The 2x2 tissue stress tensor.</span>
<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">stress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">stress</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="n">get_stress_tensor</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">stress</span></div>


<div class="viewcode-block" id="Epithelium.get_tissue_pressure"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_tissue_pressure">[docs]</a>    <span class="k">def</span> <span class="nf">get_tissue_pressure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  Isotropic part of tissue-level stress</span>

<span class="sd">        :return stress:  Isotropic componenet of stress tensor.</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_boundary_stress_tensor</span><span class="p">()</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span></div>


<div class="viewcode-block" id="Epithelium.get_stress_tensor_around_cell_cluster_depreciated"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_stress_tensor_around_cell_cluster_depreciated">[docs]</a>    <span class="k">def</span> <span class="nf">get_stress_tensor_around_cell_cluster_depreciated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate stress tensor of all the internal cells.&quot;&quot;&quot;</span>

        <span class="n">cell_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">boundary_spacings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">boundary_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>

            <span class="n">temp_ad_coords</span><span class="p">,</span> <span class="n">temps_spacings</span><span class="p">,</span> <span class="n">temps_boundary_coords</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">temp_ad_coords</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cell</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cell</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                    <span class="n">temps_spacings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">adhesion_connections_spacings</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">temps_boundary_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">adhesion_connections</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">cell_coords</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temp_ad_coords</span><span class="p">)</span>
            <span class="n">boundary_spacings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temps_spacings</span><span class="p">)</span>
            <span class="n">boundary_coords</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temps_boundary_coords</span><span class="p">)</span>

        <span class="n">cell_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell_coords</span><span class="p">)</span>
        <span class="n">boundary_spacings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">boundary_spacings</span><span class="p">)</span>
        <span class="n">boundary_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">boundary_coords</span><span class="p">)</span>

        <span class="c1"># Get the directions</span>
        <span class="n">dirs</span> <span class="o">=</span> <span class="n">cell_coords</span> <span class="o">-</span> <span class="n">boundary_coords</span>
        <span class="c1"># normalise directions</span>
        <span class="n">dirs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dirs</span><span class="p">)</span>
        <span class="n">dirs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">inner1d</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">dirs</span><span class="p">))[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

        <span class="c1"># Get forces</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cell_coords</span> <span class="o">-</span> <span class="n">boundary_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">distances</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span>
        <span class="c1"># Calc spring force</span>
        <span class="n">force</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">omega0</span> <span class="o">*</span> <span class="n">e</span>

        <span class="c1"># Scale the force according to the spacing of adhesion nodes</span>
        <span class="n">force</span> <span class="o">*=</span> <span class="n">boundary_spacings</span>

        <span class="n">vector_of_forces</span> <span class="o">=</span> <span class="n">dirs</span> <span class="o">*</span> <span class="n">force</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># Centroid</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>

        <span class="c1"># Get the stress tensor</span>
        <span class="n">stress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">force</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">r_vector</span> <span class="o">=</span> <span class="n">boundary_coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">centroid</span>
            <span class="n">stress</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">r_vector</span><span class="p">,</span> <span class="n">vector_of_forces</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">area</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">area</span>
        <span class="n">stress</span> <span class="o">/=</span> <span class="n">area</span>

        <span class="k">return</span> <span class="n">stress</span></div>


<div class="viewcode-block" id="Epithelium.get_boundary_stress_tensor"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_boundary_stress_tensor">[docs]</a>    <span class="k">def</span> <span class="nf">get_boundary_stress_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate stress tensor of the boundary stencil \todo needs to be upgraded with new adhesion class</span>
<span class="sd">        make sure factoring for spacing on both sides.</span>

<span class="sd">        :return stress:  The boundary stress tensor.</span>
<span class="sd">        :rtype: np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions_active</span><span class="p">:</span>

            <span class="c1"># Centroid</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>

            <span class="c1"># Get the stress tensor</span>
            <span class="n">stress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="s1">&#39;boundary&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update_deformed_mesh_spacing</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;boundary&#39;</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_1</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">ad</span><span class="o">.</span><span class="n">cell_2</span><span class="o">.</span><span class="n">identifier</span><span class="p">]:</span>

                    <span class="n">r_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">get_xy_at_this_end</span><span class="p">(</span><span class="n">this_cell_id</span><span class="o">=</span><span class="s1">&#39;boundary&#39;</span><span class="p">))</span> <span class="o">-</span> <span class="n">centroid</span>
                    <span class="n">force</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">get_vector_force</span><span class="p">(</span><span class="n">from_cell_id</span><span class="o">=</span><span class="s1">&#39;boundary&#39;</span><span class="p">)</span>
                    <span class="n">stress</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">r_vector</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span>

            <span class="n">area</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">area</span>
            <span class="n">stress</span> <span class="o">/=</span> <span class="n">area</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">cell_coords</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">boundary_spacings</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">boundary_coords</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>

                <span class="n">temp_ad_coords</span><span class="p">,</span> <span class="n">temps_spacings</span><span class="p">,</span> <span class="n">temps_boundary_coords</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;boundary&#39;</span><span class="p">:</span>
                            <span class="n">temp_ad_coords</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cell</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cell</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                            <span class="n">temps_spacings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">adhesion_connections_spacings</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">temps_boundary_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">adhesion_connections</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

                <span class="n">cell_coords</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temp_ad_coords</span><span class="p">)</span>
                <span class="n">boundary_spacings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temps_spacings</span><span class="p">)</span>
                <span class="n">boundary_coords</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temps_boundary_coords</span><span class="p">)</span>

            <span class="n">cell_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell_coords</span><span class="p">)</span>
            <span class="n">boundary_spacings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">boundary_spacings</span><span class="p">)</span>
            <span class="n">boundary_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">boundary_coords</span><span class="p">)</span>

            <span class="c1"># Get the directions</span>
            <span class="n">dirs</span> <span class="o">=</span> <span class="n">cell_coords</span> <span class="o">-</span> <span class="n">boundary_coords</span>
            <span class="c1"># normalise directions</span>
            <span class="n">dirs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dirs</span><span class="p">)</span>
            <span class="n">dirs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">inner1d</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">dirs</span><span class="p">))[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

            <span class="c1"># Get forces</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cell_coords</span> <span class="o">-</span> <span class="n">boundary_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">distances</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span>
            <span class="c1"># Calc spring force</span>
            <span class="n">force</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">omega0</span> <span class="o">*</span> <span class="n">e</span>

            <span class="c1"># Scale the force according to the spacing of adhesion nodes</span>
            <span class="n">force</span> <span class="o">*=</span> <span class="n">boundary_spacings</span>

            <span class="n">vector_of_forces</span> <span class="o">=</span> <span class="n">dirs</span> <span class="o">*</span> <span class="n">force</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

            <span class="c1"># Centroid</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>

            <span class="c1"># Get the stress tensor</span>
            <span class="n">stress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">force</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">r_vector</span> <span class="o">=</span> <span class="n">boundary_coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">centroid</span>
                <span class="n">stress</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">r_vector</span><span class="p">,</span> <span class="n">vector_of_forces</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">area</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">area</span>
            <span class="n">stress</span> <span class="o">/=</span> <span class="n">area</span>
        <span class="c1"># stress /= np.sum(self.get_xy_segment_lengths(self.boundary_adhesions[0], self.boundary_adhesions[1]))</span>

        <span class="c1"># eigvals, eigvecs = np.linalg.eig(stress)</span>
        <span class="c1"># evec1, evec2 = eigvecs[:, 0], eigvecs[:, 1]</span>
        <span class="c1">#</span>
        <span class="c1"># fig, ax = plt.subplots(figsize=(11, 9))</span>
        <span class="c1"># # self.plot_xy_on_trijunction(ax=ax, axEqual=True, plot_stress=0, plot_adhesion_forces=1, plotAdhesion=1,</span>
        <span class="c1"># #                             plot_boundary=1,</span>
        <span class="c1"># #                             lagrangian_tracking=0, plot_tension=1)</span>
        <span class="c1"># ax.quiver(boundary_coords[:, 0], boundary_coords[:, 1], vector_of_forces[:, 0], vector_of_forces[:, 1],</span>
        <span class="c1">#           width=0.001, scale=.0010,  # scale=.00010,</span>
        <span class="c1">#           color=&#39;r&#39;, zorder=10)</span>
        <span class="c1">#</span>
        <span class="c1"># ax.quiver(*centroid, *evec1, color=[&#39;r&#39;], scale=10)</span>
        <span class="c1"># ax.quiver(*centroid, *evec2, color=[&#39;b&#39;], scale=10)</span>
        <span class="c1">#</span>
        <span class="c1"># stress_in_AP = np.dot(stress, [1, 0])</span>
        <span class="c1"># ax.quiver(*centroid, *stress_in_AP, color=[&#39;y&#39;], scale=.0001)</span>
        <span class="c1"># stress_in_DV = np.dot(stress, [0, 1])</span>
        <span class="c1"># ax.quiver(*centroid, *stress_in_DV, color=[&#39;y&#39;], scale=.0001)</span>
        <span class="c1">#</span>
        <span class="c1"># plt.show()</span>
        <span class="c1">#</span>
        <span class="c1"># print(Tre)</span>

        <span class="k">return</span> <span class="n">stress</span></div>


<div class="viewcode-block" id="Epithelium.deform_elastic_boundary"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.deform_elastic_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">deform_elastic_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stiffness_x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stiffness_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">update_ads</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Relax tissue with an elastic BC for the boundary</span>

<span class="sd">        :param stiffness_x:  (Default value = None)  Stiffness along x-axis.</span>
<span class="sd">        :type stiffness_x: float</span>
<span class="sd">        :param stiffness_y:  (Default value = None)  Stiffness along y-axis.</span>
<span class="sd">        :type stiffness_y: float</span>
<span class="sd">        :param update_ads:  (Default value = False)  Whether to perform an update of the adhesions.</span>
<span class="sd">        :type update_ads: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span> <span class="o">+</span> <span class="mf">0.</span>

        <span class="n">stiffness_x</span> <span class="o">=</span> <span class="n">stiffness_x</span> <span class="k">if</span> <span class="n">stiffness_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_stiffness_x</span>
        <span class="n">stiffness_y</span> <span class="o">=</span> <span class="n">stiffness_y</span> <span class="k">if</span> <span class="n">stiffness_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_stiffness_y</span>

        <span class="k">if</span> <span class="n">update_ads</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">()</span>

        <span class="c1"># Get stress</span>
        <span class="n">stress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_boundary_stress_tensor</span><span class="p">()</span>

        <span class="c1"># Move boundary</span>
        <span class="n">stretch_x</span> <span class="o">=</span> <span class="n">stress</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">stiffness_x</span>
        <span class="n">stretch_y</span> <span class="o">=</span> <span class="n">stress</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">stiffness_y</span>

        <span class="c1"># Strain</span>
        <span class="n">x_strain</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">stretch_x</span>
        <span class="n">y_strain</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">stretch_y</span>

        <span class="c1"># Shift boundary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_strain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y_strain</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;boundary&#39;</span><span class="p">:</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">x_strain</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">y_strain</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">(</span><span class="n">build_trees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span></div>


<div class="viewcode-block" id="Epithelium.get_tissue_width_and_height"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_tissue_width_and_height">[docs]</a>    <span class="k">def</span> <span class="nf">get_tissue_width_and_height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Top and bottom (delta x,delta y) of max/min of boundary stencil</span>

<span class="sd">        :return width_height:  The (width, height) of the boundary stencil.</span>
<span class="sd">        :rtype: tuple</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span></div>


<div class="viewcode-block" id="Epithelium.relax_deformable_boundary"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.relax_deformable_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">relax_deformable_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stiffness_x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stiffness_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">update_adhesions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pure_shear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">max_shift</span><span class="o">=</span><span class="mf">0.025</span><span class="p">,</span> <span class="n">max_shift_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the stress at the boundary and deform it elastically, updating cell psoitions as it moves to equilibrium.</span>

<span class="sd">        :param stiffness_x:  (Default value = None)  Stiffness of boundary in x-direction.</span>
<span class="sd">        :type stiffness_x: float</span>
<span class="sd">        :param stiffness_y:  (Default value = None)  Stiffness of boundary in y-direction.</span>
<span class="sd">        :type stiffness_y: float</span>
<span class="sd">        :param update_adhesions:  (Default value = True)  Perform adhesion update?</span>
<span class="sd">        :type update_adhesions: bool</span>
<span class="sd">        :param pure_shear:  (Default value = False)  Enforce constant area?</span>
<span class="sd">        :type pure_shear: bool</span>
<span class="sd">        :param max_shift:  (Default value = 0.025)  Maximum boundary strain (can help prevent the boundary overlapping cells).</span>
<span class="sd">        :type max_shift: float</span>
<span class="sd">        :param max_shift_tol:  (Default value = 1e-4)  We don&#39;t get closer than this to a cell.</span>
<span class="sd">        :type max_shift_tol: float</span>
<span class="sd">        :return success:  Whether relaxation passed or not.</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">stiffness_x</span> <span class="o">=</span> <span class="n">stiffness_x</span> <span class="k">if</span> <span class="n">stiffness_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_stiffness_x</span>
        <span class="n">stiffness_y</span> <span class="o">=</span> <span class="n">stiffness_y</span> <span class="k">if</span> <span class="n">stiffness_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_stiffness_y</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">update_adhesions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">(</span><span class="n">only_fast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">build_trees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Get stress</span>
        <span class="n">stress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_boundary_stress_tensor</span><span class="p">()</span>

        <span class="c1"># Move boundary</span>
        <span class="n">strain_x</span> <span class="o">=</span> <span class="n">stress</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">stiffness_x</span>
        <span class="n">strain_y</span> <span class="o">=</span> <span class="n">stress</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">stiffness_y</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1">####</span>

        <span class="k">if</span> <span class="n">pure_shear</span><span class="p">:</span>
            <span class="n">biggest_stretch</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">strain_x</span><span class="p">,</span> <span class="n">strain_y</span><span class="p">])</span>
            <span class="n">strain_x</span> <span class="o">=</span> <span class="n">biggest_stretch</span>
            <span class="n">strain_y</span> <span class="o">=</span> <span class="n">biggest_stretch</span>

        <span class="c1"># Strain</span>
        <span class="n">x_stretch</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">strain_x</span>
        <span class="n">y_stretch</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">strain_y</span>

        <span class="c1"># boundary centroid</span>
        <span class="n">c_x</span><span class="p">,</span> <span class="n">c_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># min max of current and reference box</span>
        <span class="n">upper_x</span><span class="p">,</span> <span class="n">upper_x_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">lower_x</span><span class="p">,</span> <span class="n">lower_x_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">upper_y</span><span class="p">,</span> <span class="n">upper_y_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lower_y</span><span class="p">,</span> <span class="n">lower_y_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ref_x</span><span class="p">,</span> <span class="n">ref_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lower_x_ref</span><span class="p">,</span> <span class="n">upper_x_ref</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lower_y_ref</span><span class="p">,</span> <span class="n">upper_y_ref</span><span class="p">])</span>
        <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lower_x</span><span class="p">,</span> <span class="n">upper_x</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lower_y</span><span class="p">,</span> <span class="n">upper_y</span><span class="p">])</span>

        <span class="c1"># Predicted positions</span>
        <span class="n">future_x</span><span class="p">,</span> <span class="n">future_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">ref_x</span> <span class="o">-</span> <span class="n">c_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_stretch</span> <span class="o">+</span> <span class="n">c_x</span><span class="p">,</span> <span class="p">(</span><span class="n">ref_y</span> <span class="o">-</span> <span class="n">c_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">y_stretch</span> <span class="o">+</span> <span class="n">c_y</span>

        <span class="c1"># Make sure we don&#39;t get too close to a cell</span>
        <span class="n">good_movement</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">current_x</span> <span class="o">-</span> <span class="n">future_x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_shift</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">good_movement</span><span class="p">:</span>
            <span class="n">x_stretch</span> <span class="o">+=</span> <span class="mf">1e-4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x_stretch</span><span class="p">)</span>
            <span class="c1"># Predicted positions</span>
            <span class="n">future_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">ref_x</span> <span class="o">-</span> <span class="n">c_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_stretch</span> <span class="o">+</span> <span class="n">c_x</span>
            <span class="n">good_movement</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">current_x</span> <span class="o">-</span> <span class="n">future_x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_shift</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x_stretch</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_shift_tol</span>
            <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">good_movement</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">current_y</span> <span class="o">-</span> <span class="n">future_y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_shift</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">good_movement</span><span class="p">:</span>
            <span class="n">y_stretch</span> <span class="o">+=</span> <span class="mf">1e-4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_stretch</span><span class="p">)</span>
            <span class="c1"># Predicted positions</span>
            <span class="n">future_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">ref_y</span> <span class="o">-</span> <span class="n">c_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">y_stretch</span> <span class="o">+</span> <span class="n">c_y</span>
            <span class="n">good_movement</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">current_y</span> <span class="o">-</span> <span class="n">future_y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_shift</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_stretch</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_shift_tol</span>
            <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_bc</span> <span class="o">==</span> <span class="s1">&#39;viscous&#39;</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">c_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_stretch</span> <span class="o">+</span> <span class="n">c_x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">c_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">y_stretch</span> <span class="o">+</span> <span class="n">c_y</span>

            <span class="c1"># for cell in self.cells:</span>
            <span class="c1">#     c_x, c_y = np.mean(cell.x), np.mean(cell.y)</span>
            <span class="c1">#     cell.x = (cell.x - c_x) * x_stretch + c_x</span>
            <span class="c1">#     cell.y = (cell.y - c_y) * y_stretch + c_y</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_bc</span> <span class="o">==</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span>

            <span class="c1"># Shift boundary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">c_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_stretch</span> <span class="o">+</span> <span class="n">c_x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">c_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">y_stretch</span> <span class="o">+</span> <span class="n">c_y</span>

            <span class="c1"># Shift cells</span>
            <span class="c1"># See how much boundary will move</span>
            <span class="c1"># new_dx = np.max(self.boundary_adhesions[0]) - np.min(self.boundary_adhesions[0])</span>
            <span class="c1"># new_dy = np.max(self.boundary_adhesions[1]) - np.min(self.boundary_adhesions[1])</span>
            <span class="c1"># b_x_stretch = new_dx / old_dx</span>
            <span class="c1"># b_y_stretch = new_dy / old_dy</span>
            <span class="c1"># for cell in self.cells:</span>
            <span class="c1">#     c_x_cell, c_y_cell = np.mean(cell.x), np.mean(cell.y)</span>
            <span class="c1">#     cell.x = (cell.x - c_x_cell) * b_x_stretch + c_x_cell</span>
            <span class="c1">#     cell.y = (cell.y - c_y_cell) * b_y_stretch + c_y_cell</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">success</span></div>


<div class="viewcode-block" id="Epithelium.relax_eptm_with_boundary"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.relax_eptm_with_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">relax_eptm_with_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stiffness_x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stiffness_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_solves</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the stress at the boundary and relax the boundary. N.B. stress and strain names</span>
<span class="sd">         are wrong way around below.</span>

<span class="sd">        :param stiffness_x:  (Default value = None)  Stiffness of boundary in x-direction.</span>
<span class="sd">        :type stiffness_x: float</span>
<span class="sd">        :param stiffness_y:  (Default value = None)  Stiffness of boundary in y-direction.</span>
<span class="sd">        :type stiffness_y: float</span>
<span class="sd">        :param max_solves:  (Default value = 1)  Maximum jiggles to try to get to equilibrium before giving up.</span>
<span class="sd">        :type max_solves: in</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">stiffness_x</span> <span class="o">=</span> <span class="n">stiffness_x</span> <span class="k">if</span> <span class="n">stiffness_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_stiffness_x</span>
        <span class="n">stiffness_y</span> <span class="o">=</span> <span class="n">stiffness_y</span> <span class="k">if</span> <span class="n">stiffness_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_stiffness_y</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">(</span><span class="n">only_fast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">build_trees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">solve_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_solves</span><span class="p">):</span>

            <span class="c1"># Get stress and move boundary</span>
            <span class="n">stress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_boundary_stress_tensor</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relax_deformable_boundary</span><span class="p">()</span>

            <span class="c1"># Relax</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solve_bvps_in_parallel</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">total_elastic_relaxes</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">total_elastic_relaxes</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Epithelium.relax_eptm_with_germband_bcs"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.relax_eptm_with_germband_bcs">[docs]</a>    <span class="k">def</span> <span class="nf">relax_eptm_with_germband_bcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">posterior_pull_shift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stiffness_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_solves</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Relax eptm with BCs from GBE. Viscous D-V, fixed anterior and posterior pull.</span>
<span class="sd">        NB this is very specific to the fixed boundary with 14 cells.</span>

<span class="sd">        :param posterior_pull_shift:  (Default value = None)  Strain to apply to the right boundary nodes.</span>
<span class="sd">        :type posterior_pull_shift: float</span>
<span class="sd">        :param stiffness_y:  (Default value = None)  Tissue stiffness in y.</span>
<span class="sd">        :type stiffness_y: float</span>
<span class="sd">        :param max_solves:  (Default value = 5)  Maximum jiggles to try before giving up.</span>
<span class="sd">        :type max_solves: int</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">14</span><span class="p">,</span> <span class="s2">&quot;Must be 14 cells with fixed boundary.&quot;</span>

        <span class="n">posterior_pull_shift</span> <span class="o">=</span> <span class="n">posterior_pull_shift</span> <span class="k">if</span> <span class="n">posterior_pull_shift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">posterior_pull_shift</span>

        <span class="c1"># Get boundary adhesions, find RHS and pull</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span>
        <span class="c1"># Get reference</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Angles to each point relative to centroid</span>
        <span class="n">angles_from_centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Local tangent angles</span>
        <span class="n">local_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="c1"># Find the corners as points where the tangents change angle</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">local_angles</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">local_angles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">local_angles</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">50</span><span class="p">])</span>
        <span class="c1"># angle to corners</span>
        <span class="n">centroid_corner_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">corners</span><span class="p">]</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">corners</span><span class="p">]</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">centroid_corner_angles</span><span class="p">[</span><span class="n">centroid_corner_angles</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="c1"># order by angle</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">centroid_corner_angles</span><span class="p">)</span>
        <span class="n">centroid_corner_angles</span> <span class="o">=</span> <span class="n">centroid_corner_angles</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>
        <span class="c1"># Find the RHS is defined as points between 2 corners</span>
        <span class="n">min_angle</span><span class="p">,</span> <span class="n">max_angle</span> <span class="o">=</span> <span class="n">centroid_corner_angles</span><span class="p">[</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">centroid_corner_angles</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">min_angle</span> <span class="o">&lt;=</span> <span class="n">angles_from_centroid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">angles_from_centroid</span> <span class="o">&lt;=</span> <span class="n">max_angle</span><span class="p">))</span>

        <span class="c1"># Shift rhs based on these values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span> <span class="o">+=</span> <span class="n">posterior_pull_shift</span>

        <span class="c1"># Now relax internal cells, but fix the A-P sides</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relax_eptm_with_boundary</span><span class="p">(</span><span class="n">stiffness_x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">stiffness_y</span><span class="o">=</span><span class="n">stiffness_y</span><span class="p">,</span> <span class="n">max_solves</span><span class="o">=</span><span class="n">max_solves</span><span class="p">)</span>

        <span class="k">return</span></div>


<div class="viewcode-block" id="Epithelium.update_adhesion_distances_identifiers_and_indices_for_all_cortices"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.update_adhesion_distances_identifiers_and_indices_for_all_cortices">[docs]</a>    <span class="k">def</span> <span class="nf">update_adhesion_distances_identifiers_and_indices_for_all_cortices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the distances to all adhesions and the identies of the cortices.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">update_adhesion_distances_identifiers_and_indices</span><span class="p">()</span></div>


<div class="viewcode-block" id="Epithelium.update_adhesions_for_hexagons"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.update_adhesions_for_hexagons">[docs]</a>    <span class="k">def</span> <span class="nf">update_adhesions_for_hexagons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For only 1 cell.  The cell is placed in a hexagonal wall and finds adhesions to the boundary.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Updating adhesions for hexagons&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">adhesion_point_coords</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

            <span class="n">rNew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
            <span class="n">numPoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">rNew</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">rNew</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span>

            <span class="n">pointsX</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">6</span><span class="p">),</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
            <span class="n">pointsX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pointsX</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">pointsY</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">6</span><span class="p">),</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
            <span class="n">pointsY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

            <span class="n">points_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">pointsX</span><span class="p">,</span> <span class="n">pointsY</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Get spacing</span>
            <span class="n">spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xy_segment_lengths</span><span class="p">(</span><span class="n">pointsX</span><span class="p">,</span> <span class="n">pointsY</span><span class="p">)</span>

            <span class="c1"># Clear current adhesions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clear_adhesion_points</span><span class="p">()</span>

            <span class="c1"># Add new adhesions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">update_adhesion_points</span><span class="p">(</span><span class="n">points_all</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;boundary&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">pointsX</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">spacing</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">update_adhesion_distances_identifiers_and_indices</span><span class="p">(</span><span class="n">build_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="s1">&#39;boundary&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># if not hasattr(self, &#39;boundary_adhesions&#39;):</span>
                <span class="c1"># Save</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span> <span class="o">=</span> <span class="p">[</span><span class="n">pointsX</span><span class="p">,</span> <span class="n">pointsY</span><span class="p">]</span>
                <span class="c1"># Make boundary cell</span>
                <span class="n">initial_guessesA</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="p">[],</span>
                                    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="n">initial_guesses</span><span class="o">=</span><span class="n">initial_guessesA</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;boundary&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">prune_adhesion_data</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">x</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">y</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="s1">&#39;boundary&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span>
                <span class="c1"># self.boundary_cell.s_index_dict = {s: idx for (idx, s) in enumerate(self.boundary_cell.s)}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="s1">&#39;boundary&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update_deformed_mesh_spacing</span><span class="p">()</span></div>


<div class="viewcode-block" id="Epithelium.prune_slow_adhesions_by_length"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.prune_slow_adhesions_by_length">[docs]</a>    <span class="k">def</span> <span class="nf">prune_slow_adhesions_by_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove slow adhesions if they are longer than &#39;max_length&#39;</span>

<span class="sd">        :param max_length:  Adhesions with length above this will be discarded.</span>
<span class="sd">        :type max_length: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pruning slow adhesions longer than </span><span class="si">{</span><span class="n">max_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span> <span class="o">=</span> <span class="p">[</span><span class="n">ad</span> <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span> <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">get_length</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">max_length</span><span class="p">]</span></div>


<div class="viewcode-block" id="Epithelium.update_slow_adhesions"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.update_slow_adhesions">[docs]</a>    <span class="k">def</span> <span class="nf">update_slow_adhesions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prune</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the slow adhesions in the tissue and then store in every cell</span>
<span class="sd">        To save memory, slow adhesions are stored in Cell class as:</span>
<span class="sd">        slow_ad = (local_cell_index, other_cell_x, other_cell_y, other_cell_mesh_spacing)</span>
<span class="sd">        rather than as adhesion objects.</span>

<span class="sd">        :param prune:  (Default value = False)  Remove adhesions based on lifetime.</span>
<span class="sd">        :type prune: bool</span>
<span class="sd">        :param apply_to:  (Default value = &#39;all&#39;)  If not ``&#39;all&#39;``, a list of cell identifiers that the function will be applied to.</span>
<span class="sd">        :type apply_to: list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Updating slow adhesions&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions_active</span><span class="p">:</span>

            <span class="n">apply_to</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span> <span class="k">if</span> <span class="n">apply_to</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="k">else</span> <span class="n">apply_to</span>

            <span class="c1"># keep a record of the nodes with a surviving adhesion after filtering</span>
            <span class="n">connected_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>

            <span class="c1"># # Filter the existing connections and get whats left</span>
            <span class="c1"># if len(self.slow_adhesions) &gt; 0 and prune:</span>
            <span class="c1">#     # Make a probabitlty distribution based on distances</span>
            <span class="c1">#     adhesion_distances = [1 / ad.get_length() for ad in self.slow_adhesions]</span>
            <span class="c1">#     sum_of_distance = sum(adhesion_distances)</span>
            <span class="c1">#     probabilities = [d/sum_of_distance for d in adhesion_distances]</span>
            <span class="c1">#</span>
            <span class="c1">#     # take a sample of the adhesions based on probabilities from distance</span>
            <span class="c1">#     number_of_ads_to_pick = int((1 / self.slow_adhesion_lifespan) * len(self.slow_adhesions))</span>
            <span class="c1">#     self.slow_adhesions = list(np.random.choice(self.slow_adhesions, number_of_ads_to_pick,</span>
            <span class="c1">#                                       p=probabilities, replace=False))</span>

            <span class="c1"># Remove slow adhesions randomly, based on lifetime in exponential distribution</span>
            <span class="n">surviving_ads</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">prune</span><span class="p">:</span>
                    <span class="n">max_cortex_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">get_angle_relative_to_cortices</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                    <span class="c1"># beta = self.slow_adhesion_lifespan * max_cortex_angle</span>
                    <span class="c1"># keep_adhesion = self.slow_adhesion_lifespan &gt;= np.random.exponential(beta)</span>
                    <span class="n">keep_adhesion</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">age</span> <span class="o">&lt;=</span> <span class="n">ad</span><span class="o">.</span><span class="n">lifespan</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_cortex_angle</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_shear_unbinding_factor</span><span class="p">)</span>
                    <span class="n">keep_adhesion</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">get_length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max_adhesion_length</span> <span class="k">else</span> <span class="n">keep_adhesion</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">keep_adhesion</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="n">keep_adhesion</span><span class="p">:</span>
                    <span class="n">connected_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">([(</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_1</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">ad</span><span class="o">.</span><span class="n">cell_1_s</span><span class="p">)])</span>
                    <span class="n">connected_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">([(</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_2</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">ad</span><span class="o">.</span><span class="n">cell_2_s</span><span class="p">)])</span>

                    <span class="n">surviving_ads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ad</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span> <span class="o">=</span> <span class="n">surviving_ads</span>

            <span class="c1"># Build a tree between all nodes and get nearest neighbours, then connect nodes without a slow ad.</span>
            <span class="n">all_points</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">all_identifiers</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">local_index</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
                <span class="n">all_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">cell</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">all_identifiers</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">cell</span><span class="o">.</span><span class="n">identifier</span><span class="p">]</span> <span class="o">*</span> <span class="n">cell</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="c1"># local_index.extend([i for i in range(cell.x.size)])</span>
                <span class="n">local_index</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">s</span><span class="p">])</span>
            <span class="c1"># Num nodes from cells</span>
            <span class="n">num_cell_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_identifiers</span><span class="p">)</span>
            <span class="c1"># Add the wall</span>
            <span class="n">all_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">all_identifiers</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;boundary&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">local_index</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">s</span><span class="p">])</span>

            <span class="n">tissue_tree</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max_adhesion_length</span><span class="p">,</span>
                                           <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">all_points</span><span class="p">)</span>
            <span class="n">dists</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">tissue_tree</span><span class="o">.</span><span class="n">radius_neighbors</span><span class="p">(</span><span class="n">all_points</span><span class="p">[:</span><span class="n">num_cell_nodes</span><span class="p">],</span> <span class="n">sort_results</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Filter out ones with same identity</span>
            <span class="n">adhesion_pairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
                <span class="n">naboer</span> <span class="o">=</span> <span class="p">[</span><span class="n">nabo_id</span> <span class="k">for</span> <span class="n">nabo_id</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">all_identifiers</span><span class="p">[</span><span class="n">nabo_id</span><span class="p">]</span> <span class="o">!=</span> <span class="n">all_identifiers</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">naboer</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">adhesion_pairs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">naboer</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
            <span class="c1"># adhesion_pairs = {frozenset([i, [nabo_id for nabo_id in indices[i]</span>
            <span class="c1">#                                  if all_identifiers[nabo_id] != all_identifiers[i]][0]])</span>
            <span class="c1">#                                  for i in range(len(indices))}</span>
            <span class="n">adhesion_pairs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">adhesion_pairs</span><span class="p">]</span>

            <span class="c1"># Store all data</span>
            <span class="c1"># Append the adhesions if connections don&#39;t already exist</span>
            <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">adhesion_pairs</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">all_identifiers</span><span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">!=</span> <span class="s1">&#39;boundary&#39;</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="n">all_identifiers</span><span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">local_index</span><span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">connected_nodes</span><span class="p">)</span> <span class="ow">or</span> \
                   <span class="p">(</span><span class="n">all_identifiers</span><span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">!=</span> <span class="s1">&#39;boundary&#39;</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="n">all_identifiers</span><span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">local_index</span><span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">connected_nodes</span><span class="p">):</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Adhesion</span><span class="p">(</span><span class="n">cells</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">all_identifiers</span><span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span>
                                                               <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">all_identifiers</span><span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]),</span>
                                                        <span class="n">s_coords</span><span class="o">=</span><span class="p">(</span><span class="n">local_index</span><span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">local_index</span><span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
                                                        <span class="n">average_lifespan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesion_lifespan</span><span class="p">,</span>
                                                        <span class="n">adhesion_type</span><span class="o">=</span><span class="s1">&#39;cadherin&#39;</span><span class="p">))</span>
                    <span class="n">connected_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">([(</span><span class="n">all_identifiers</span><span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">local_index</span><span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]])])</span>
                    <span class="n">connected_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">([(</span><span class="n">all_identifiers</span><span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">local_index</span><span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]])])</span>

            <span class="c1"># Add the data at the cell level</span>
            <span class="c1"># Slow adhesion entry = (local_cell_index, other_cell_x, other_cell_y, other_cell_mesh_spacing)</span>
            <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">slow_adhesions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span><span class="p">:</span>
                <span class="n">ad_cell_1</span><span class="p">,</span> <span class="n">ad_cell_2</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">cell_1</span><span class="p">,</span> <span class="n">ad</span><span class="o">.</span><span class="n">cell_2</span>
                <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">cell_1</span><span class="o">.</span><span class="n">identifier</span> <span class="ow">in</span> <span class="n">apply_to</span><span class="p">:</span>
                    <span class="c1"># ad.cell_1.slow_adhesions.append(ad)</span>
                    <span class="n">xy_nabo</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">get_xy_at_other_end</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_1</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>
                    <span class="n">ad</span><span class="o">.</span><span class="n">cell_1</span><span class="o">.</span><span class="n">slow_adhesions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_1_index</span><span class="p">,</span> <span class="n">xy_nabo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xy_nabo</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                     <span class="n">ad_cell_2</span><span class="o">.</span><span class="n">deformed_mesh_spacing</span><span class="p">[</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_2_index</span><span class="p">]])</span>
                <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">cell_2</span><span class="o">.</span><span class="n">identifier</span> <span class="ow">in</span> <span class="n">apply_to</span><span class="p">:</span>
                    <span class="c1"># ad.cell_2.slow_adhesions.append(ad)</span>
                    <span class="n">xy_nabo</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">get_xy_at_other_end</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_2</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>
                    <span class="n">ad</span><span class="o">.</span><span class="n">cell_2</span><span class="o">.</span><span class="n">slow_adhesions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_2_index</span><span class="p">,</span> <span class="n">xy_nabo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xy_nabo</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                     <span class="n">ad_cell_1</span><span class="o">.</span><span class="n">deformed_mesh_spacing</span><span class="p">[</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_1_index</span><span class="p">]])</span></div>


<div class="viewcode-block" id="Epithelium.update_sidekick_adhesions"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.update_sidekick_adhesions">[docs]</a>    <span class="k">def</span> <span class="nf">update_sidekick_adhesions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fresh_sdk</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the sidekick vertices in the tissue and then add data to cells.</span>
<span class="sd">        As with slow adhesions, these are stored in the Cell classes as:</span>
<span class="sd">        slow_ad = (local_cell_index, other_cell_x, other_cell_y, other_cell_mesh_spacing)</span>
<span class="sd">        rather than as adhesion objects.</span>

<span class="sd">        :param fresh_sdk:  (Default value = True)  Remove the existing sidekick and make new ones.</span>
<span class="sd">        :type fresh_sdk: bool</span>
<span class="sd">        :param apply_to:  (Default value = &#39;all&#39;)  If not ``&#39;all&#39;``, a list of cell identifiers that the function will be applied to.</span>
<span class="sd">        :type apply_to: list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Updating sidekick adhesions&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">apply_to</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span> <span class="k">if</span> <span class="n">apply_to</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="k">else</span> <span class="n">apply_to</span>

        <span class="k">if</span> <span class="n">fresh_sdk</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">apply_to_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">apply_to</span><span class="p">)</span>
            <span class="n">tissue_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all_tissue_vertices</span><span class="p">(</span><span class="n">apply_to</span><span class="o">=</span><span class="n">apply_to</span><span class="p">)</span>
            <span class="n">sidekick_vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tissue_vertices</span> <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">apply_to_set</span><span class="p">)]</span>
            <span class="c1"># Add s_coords of vertices in tuple form (&#39;cell_id&#39;, s_loc)</span>
            <span class="n">sidekick_vertices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cortex_coord_of_vertex_triangle</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">)))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sidekick_vertices</span><span class="p">]</span>

            <span class="c1"># Add the vertices as adhesions to each cell</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="n">sidekick_vertices</span><span class="p">:</span>
                <span class="c1"># Append all three adhesions</span>
                <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Adhesion</span><span class="p">(</span><span class="n">cells</span><span class="o">=</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">),</span> <span class="n">s_coords</span><span class="o">=</span><span class="p">(</span><span class="n">c1</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="n">c2</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]),</span>
                                                        <span class="n">average_lifespan</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                                                        <span class="n">adhesion_type</span><span class="o">=</span><span class="s1">&#39;sidekick&#39;</span><span class="p">))</span>
                <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Adhesion</span><span class="p">(</span><span class="n">cells</span><span class="o">=</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">),</span> <span class="n">s_coords</span><span class="o">=</span><span class="p">(</span><span class="n">c1</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="n">c2</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]]),</span>
                                                        <span class="n">average_lifespan</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                                                        <span class="n">adhesion_type</span><span class="o">=</span><span class="s1">&#39;sidekick&#39;</span><span class="p">))</span>
                <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Adhesion</span><span class="p">(</span><span class="n">cells</span><span class="o">=</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">),</span> <span class="n">s_coords</span><span class="o">=</span><span class="p">(</span><span class="n">c1</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="n">c2</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]]),</span>
                                                        <span class="n">average_lifespan</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                                                        <span class="n">adhesion_type</span><span class="o">=</span><span class="s1">&#39;sidekick&#39;</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">sidekick_adhesions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Add the adhesions to cells.</span>
        <span class="c1"># sdk adhesion entry in a cell = (local_cell_index, other_cell_x, other_cell_y)</span>
        <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">cell_1</span><span class="o">.</span><span class="n">identifier</span> <span class="ow">in</span> <span class="n">apply_to</span><span class="p">:</span>
                <span class="c1"># ad.cell_1.sidekick_adhesions.append(ad)</span>
                <span class="n">xy_nabo</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">get_xy_at_other_end</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_1</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>
                <span class="n">ad</span><span class="o">.</span><span class="n">cell_1</span><span class="o">.</span><span class="n">sidekick_adhesions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_1_index</span><span class="p">,</span> <span class="n">xy_nabo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xy_nabo</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">ad</span><span class="o">.</span><span class="n">cell_2</span><span class="o">.</span><span class="n">identifier</span> <span class="ow">in</span> <span class="n">apply_to</span><span class="p">:</span>
                <span class="c1"># ad.cell_2.sidekick_adhesions.append(ad)</span>
                <span class="n">xy_nabo</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">get_xy_at_other_end</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_2</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>
                <span class="n">ad</span><span class="o">.</span><span class="n">cell_2</span><span class="o">.</span><span class="n">sidekick_adhesions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_2_index</span><span class="p">,</span> <span class="n">xy_nabo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xy_nabo</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span></div>


<div class="viewcode-block" id="Epithelium.update_fast_adhesions"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.update_fast_adhesions">[docs]</a>    <span class="k">def</span> <span class="nf">update_fast_adhesions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">build_trees</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the population of fast turnover adhesions, tau_ad &lt; tau_cortex</span>
<span class="sd">        Adds the current positions of the cortices as the possible adhesion points for each cortex</span>

<span class="sd">        :param build_trees:  (Default value = True)  Rebuild the parameter trees with adhesion nodes.</span>
<span class="sd">        :type build_trees: bool</span>
<span class="sd">        :param apply_to:  (Default value = &#39;all&#39;)  If not ``&#39;all&#39;``, a list of cell identifiers that the function will be applied to.</span>
<span class="sd">        :type apply_to: list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">building_text</span> <span class="o">=</span> <span class="s2">&quot;and building new tree&quot;</span> <span class="k">if</span> <span class="n">build_trees</span> <span class="k">else</span> <span class="s2">&quot;but not building new tree&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;updating fast adhesions on all cortices &quot;</span><span class="p">,</span> <span class="n">building_text</span><span class="p">]),</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Build a list with all of the points, spacings and identifiers.</span>
        <span class="n">all_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_spacings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_identifiers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">all_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">cell</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">all_spacings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">get_xy_segment_lengths</span><span class="p">())</span>
            <span class="n">all_identifiers</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">cell</span><span class="o">.</span><span class="n">identifier</span><span class="p">]</span> <span class="o">*</span> <span class="n">cell</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="c1"># Add the wall</span>
        <span class="n">all_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">all_spacings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_xy_segment_lengths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">all_identifiers</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;boundary&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1"># Need arrays</span>
        <span class="n">all_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_points</span><span class="p">)</span>
        <span class="n">all_spacings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_spacings</span><span class="p">)</span>
        <span class="n">all_identifiers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_identifiers</span><span class="p">)</span>

        <span class="c1"># For every cell add the possible adhesions within max_adhesion_length</span>
        <span class="n">apply_to</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span> <span class="k">if</span> <span class="n">apply_to</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="k">else</span> <span class="n">apply_to</span>
        <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">apply_to</span><span class="p">:</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span>
            <span class="c1"># Minimum distance criterion</span>
            <span class="n">cuttoff</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">adhesion_search_radius</span> <span class="o">*</span> <span class="mf">1.1</span>

            <span class="c1"># Cell coords</span>
            <span class="n">cell_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">cell</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># On the fixed wall</span>
            <span class="n">indices_to_adhesions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indices_of_points_within_distance</span><span class="p">(</span><span class="n">all_points</span><span class="p">,</span> <span class="n">cell_coords</span><span class="p">,</span> <span class="n">cuttoff</span><span class="p">)</span>

            <span class="c1"># Filter the big lists</span>
            <span class="n">adhesions_reached</span> <span class="o">=</span> <span class="n">all_points</span><span class="p">[</span><span class="n">indices_to_adhesions</span><span class="p">]</span>
            <span class="n">adhesions_reached_spacings</span> <span class="o">=</span> <span class="n">all_spacings</span><span class="p">[</span><span class="n">indices_to_adhesions</span><span class="p">]</span>
            <span class="n">adhesions_reached_identifiers</span> <span class="o">=</span> <span class="n">all_identifiers</span><span class="p">[</span><span class="n">indices_to_adhesions</span><span class="p">]</span>

            <span class="c1"># Filter out this cell</span>
            <span class="n">adhesions_reached</span> <span class="o">=</span> <span class="n">adhesions_reached</span><span class="p">[</span><span class="n">adhesions_reached_identifiers</span> <span class="o">!=</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span><span class="p">]</span>
            <span class="n">adhesions_reached_spacings</span> <span class="o">=</span> <span class="n">adhesions_reached_spacings</span><span class="p">[</span><span class="n">adhesions_reached_identifiers</span> <span class="o">!=</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span><span class="p">]</span>
            <span class="n">adhesions_reached_identifiers</span> <span class="o">=</span> <span class="n">adhesions_reached_identifiers</span><span class="p">[</span>
                <span class="n">adhesions_reached_identifiers</span> <span class="o">!=</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span><span class="p">]</span>

            <span class="c1"># Store</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">update_adhesion_points</span><span class="p">(</span><span class="n">adhesions_reached</span><span class="p">,</span> <span class="n">adhesions_reached_identifiers</span><span class="p">,</span>
                                        <span class="n">adhesions_reached_spacings</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">build_trees</span><span class="p">:</span>
                <span class="c1"># cell.build_adhesion_tree()</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">update_adhesion_distances_identifiers_and_indices</span><span class="p">(</span><span class="n">build_tree</span><span class="o">=</span><span class="n">build_trees</span><span class="p">)</span></div>


<div class="viewcode-block" id="Epithelium.update_adhesion_points_between_all_cortices"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.update_adhesion_points_between_all_cortices">[docs]</a>    <span class="k">def</span> <span class="nf">update_adhesion_points_between_all_cortices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">only_fast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">build_trees</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                                                    <span class="n">fresh_sdk</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prune_slow</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update all specified adhesion types.</span>
<span class="sd">        By default, doesn&#39;t prune slow because they may be updated before time progresses</span>

<span class="sd">        :param only_fast:  (Default value = False)  Update only fast adhesions (and thereby prestretches).</span>
<span class="sd">        :type only_fast: bool</span>
<span class="sd">        :param build_trees:  (Default value = True)  Update adhesion trees.</span>
<span class="sd">        :type build_trees: bool</span>
<span class="sd">        :param apply_to:  (Default value = &#39;all&#39;)  If not ``&#39;all&#39;``, a list of cell identifiers that the function will be applied to.</span>
<span class="sd">        :type apply_to: list</span>
<span class="sd">        :param fresh_sdk:  (Default value = False)  Update sidkekick adhesions.</span>
<span class="sd">        :type fresh_sdk: bool</span>
<span class="sd">        :param prune_slow:  (Default value = False)  Remove old and long slow adhesions.</span>
<span class="sd">        :type prune_slow: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Verbose info</span>
        <span class="n">building_text</span> <span class="o">=</span> <span class="s2">&quot;and building new tree&quot;</span> <span class="k">if</span> <span class="n">build_trees</span> <span class="k">else</span> <span class="s2">&quot;but not building new tree&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;updating adhesion points on all cortices &quot;</span><span class="p">,</span> <span class="n">building_text</span><span class="p">]),</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">within_hexagons</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesions_for_hexagons</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_adhesions_for_free_boundary_hexagons</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_adhesion_to_fixed_line_bool</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Fast adhesions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_fast_adhesions</span><span class="p">(</span><span class="n">build_trees</span><span class="o">=</span><span class="n">build_trees</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="n">apply_to</span><span class="p">)</span>

            <span class="c1"># # We need to update the s_index dict if it&#39;s empty from saving</span>
            <span class="c1"># if self.slow_adhesions_active or self.sidekick_active:</span>
            <span class="c1">#     for cell in self.cells:</span>
            <span class="c1">#         if cell.s_index_dict == 0:</span>
            <span class="c1">#             cell.s_index_dict = {s: idx for (idx, s) in enumerate(cell.s)}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">only_fast</span><span class="p">:</span>

            <span class="c1"># Slow adhesion population</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions_active</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_slow_adhesions</span><span class="p">(</span><span class="n">prune</span><span class="o">=</span><span class="n">prune_slow</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="n">apply_to</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">slow_adhesions</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Sidekick</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_active</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_sidekick_adhesions</span><span class="p">(</span><span class="n">fresh_sdk</span><span class="o">=</span><span class="n">fresh_sdk</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="n">apply_to</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
                    <span class="n">cell</span><span class="o">.</span><span class="n">sidekick_adhesions</span> <span class="o">=</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="Epithelium.remove_sdk_from_a_junction"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.remove_sdk_from_a_junction">[docs]</a>    <span class="k">def</span> <span class="nf">remove_sdk_from_a_junction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">junc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes sdk from the vertices of a junction defined as junc = [cell_ref_1, cell_ref_2]</span>

<span class="sd">        :param junc:  A list of the two cell identities that make the bicellular junction.</span>
<span class="sd">        :type junc: list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">junc</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">junc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">assert</span> <span class="p">(</span><span class="n">junc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">))</span> <span class="ow">or</span>
                <span class="n">junc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">c1</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">))),</span> \
            <span class="s2">&quot;Error, cells </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2"> don&#39;t share a junction&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">junc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">junc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Store a list of all cells connected to the junction vertices</span>
        <span class="n">cells_at_junction_vertices</span> <span class="o">=</span> <span class="p">{</span><span class="n">c1</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">c2</span><span class="o">.</span><span class="n">identifier</span><span class="p">}</span>
        <span class="c1"># First get the other cells connected to the vertices</span>
        <span class="c1"># Get neighbours of both cells</span>
        <span class="n">naboer</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">c1</span><span class="o">.</span><span class="n">get_neighbours</span><span class="p">())</span>
        <span class="n">naboer</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">get_neighbours</span><span class="p">())</span>
        <span class="c1"># If a neighbour contains c1 and c2, then it belongs to the vertex</span>
        <span class="k">for</span> <span class="n">nabo_ref</span> <span class="ow">in</span> <span class="n">naboer</span><span class="p">:</span>
            <span class="n">nabo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">nabo_ref</span><span class="p">]</span>
            <span class="n">nabo_naboer</span> <span class="o">=</span> <span class="n">nabo</span><span class="o">.</span><span class="n">get_neighbours</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">junc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">nabo_naboer</span> <span class="ow">and</span> <span class="n">junc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">nabo_naboer</span><span class="p">:</span>
                <span class="n">cells_at_junction_vertices</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">nabo</span><span class="o">.</span><span class="n">identifier</span><span class="p">])</span>

        <span class="c1"># Now remove all sdk triangles where all cells are at these vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span> <span class="o">=</span> <span class="p">[</span><span class="n">ad</span> <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span> <span class="k">if</span> <span class="ow">not</span>
                                   <span class="p">{</span><span class="n">ad</span><span class="o">.</span><span class="n">cell_1</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">ad</span><span class="o">.</span><span class="n">cell_2</span><span class="o">.</span><span class="n">identifier</span><span class="p">}</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">cells_at_junction_vertices</span><span class="p">)]</span></div>


<div class="viewcode-block" id="Epithelium.get_indices_of_points_within_distance"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_indices_of_points_within_distance">[docs]</a>    <span class="k">def</span> <span class="nf">get_indices_of_points_within_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points1</span><span class="p">,</span> <span class="n">points2</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function to return the indices of points 1 that are within &#39;cutoff&#39; of points 2.</span>
<span class="sd">        \todo make a sklearn tree of the wall to increase speed.</span>

<span class="sd">        :param points1:  The list of (x,y) points that will find nearest points in points2</span>
<span class="sd">        :type points1: list</span>
<span class="sd">        :param points2:  The reference list of points.</span>
<span class="sd">        :type points2: list</span>
<span class="sd">        :param cutoff:  Maximum search distance.</span>
<span class="sd">        :type cutoff: float</span>
<span class="sd">        :return indices:  The indices of points1 list that are within cutoff to points2.</span>
<span class="sd">        :rtype: list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># build the KDTree using the *larger* points array</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">points1</span><span class="p">)</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">points2</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">groups</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">indices</span></div>


<div class="viewcode-block" id="Epithelium.smooth_all_variables_with_spline"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.smooth_all_variables_with_spline">[docs]</a>    <span class="k">def</span> <span class="nf">smooth_all_variables_with_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply_to</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Use a spline to smooth the variables.</span>

<span class="sd">        :param apply_to:  (Default value = &#39;all&#39;)  If not ``&#39;all&#39;``, a list of cell identifiers that the function will be applied to.</span>
<span class="sd">        :type apply_to: list</span>
<span class="sd">        :param smoothing:  (Default value = 1e-3)  How much smoothing to apply.</span>
<span class="sd">        :type smoothing: float</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">apply_to</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span> <span class="k">if</span> <span class="n">apply_to</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="k">else</span> <span class="n">apply_to</span>

        <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">apply_to</span><span class="p">:</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span>

            <span class="n">theta_spline</span> <span class="o">=</span> <span class="n">splrep</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">smoothing</span><span class="p">)</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">theta_spline</span><span class="p">)</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">theta_spline</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">theta_spline</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">x_spline</span> <span class="o">=</span> <span class="n">splrep</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">smoothing</span><span class="p">)</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">x_spline</span><span class="p">)</span>
            <span class="n">y_spline</span> <span class="o">=</span> <span class="n">splrep</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">smoothing</span><span class="p">)</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">y_spline</span><span class="p">)</span>

            <span class="n">gamma_spline</span> <span class="o">=</span> <span class="n">splrep</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">smoothing</span><span class="p">)</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">gamma_spline</span><span class="p">)</span></div>


<div class="viewcode-block" id="Epithelium.decimate_all_cells_onto_new_grid"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.decimate_all_cells_onto_new_grid">[docs]</a>    <span class="k">def</span> <span class="nf">decimate_all_cells_onto_new_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Changes &#39;n&#39; for every cell by interpolating their variables onto a new grid.</span>

<span class="sd">        :param factor:  The factor which which to scale the number of cortex nodes.</span>
<span class="sd">        :type factor: int</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Decimating cortex variables by a factor of </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">factor</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">decimate_all_variables_onto_new_grid</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">decimate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">factor</span><span class="p">),</span>
                                            <span class="n">decimate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">factor</span><span class="p">)])</span></div>


<div class="viewcode-block" id="Epithelium.set_cables_in_eptm"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.set_cables_in_eptm">[docs]</a>    <span class="k">def</span> <span class="nf">set_cables_in_eptm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prestretch</span><span class="p">,</span> <span class="n">id1_cells</span><span class="o">=</span><span class="p">[],</span> <span class="n">id2_cells</span><span class="o">=</span><span class="p">[],</span> <span class="n">cable_type</span><span class="o">=</span><span class="s1">&#39;bipolar&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialises PCP cables in the epithelium by assigning prestrain to mis-matched identities</span>

<span class="sd">        :param prestretch:  The magnitude of prestretch to apply to the cortices</span>
<span class="sd">        :type prestretch: float</span>
<span class="sd">        :param id1_cells:  (Default value = [])  List of cells to be identity 1</span>
<span class="sd">        :type id1_cells: list</span>
<span class="sd">        :param id2_cells:  (Default value = [])  List of cells to be identity 2</span>
<span class="sd">        :type id2_cells: list</span>
<span class="sd">        :param cable_type:  (Default value = &#39;bipolar&#39;)  unipolar or bipolar cables.</span>
<span class="sd">        :type cable_type: string</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">cable_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;unipolar&#39;</span><span class="p">,</span> <span class="s1">&#39;bipolar&#39;</span><span class="p">],</span> <span class="s2">&quot;Cable must be bipolar or unipolar&quot;</span>

        <span class="c1"># Bestow identities</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">id1_cells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">id1_cells</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">]</span>
                <span class="c1"># id1_cells = [&#39;I&#39;, &#39;E&#39;, &#39;G&#39;, &#39;A&#39;, &#39;K&#39;, &#39;M&#39;]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">id2_cells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">id2_cells</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span> <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">id1_cells</span><span class="p">]</span>

        <span class="c1"># Add prestrain properly</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="c1"># Identify the id</span>
            <span class="k">if</span> <span class="n">cable_type</span> <span class="o">==</span> <span class="s1">&#39;bipolar&#39;</span><span class="p">:</span>
                <span class="n">cells_to_add_prestrain</span> <span class="o">=</span> <span class="n">id1_cells</span> <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="ow">in</span> <span class="n">id2_cells</span> <span class="k">else</span> <span class="n">id2_cells</span>
            <span class="k">elif</span> <span class="n">cable_type</span> <span class="o">==</span> <span class="s1">&#39;unipolar&#39;</span><span class="p">:</span>
                <span class="n">cells_to_add_prestrain</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="ow">in</span> <span class="n">id2_cells</span> <span class="k">else</span> <span class="n">id2_cells</span>
            <span class="c1"># Update</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">cells_to_add_prestrain</span><span class="p">,</span> <span class="n">prestretch</span><span class="p">))</span></div>


<div class="viewcode-block" id="Epithelium.impose_pcp"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.impose_pcp">[docs]</a>    <span class="k">def</span> <span class="nf">impose_pcp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prestretch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies prestrain to all vertical junctions.  Works only in the 14-cell tissue.</span>

<span class="sd">        :param prestretch:  The magnitude of prestretch.</span>
<span class="sd">        :type prestretch: float</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="s1">&#39;A&#39;</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="n">prestretch</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">],</span> <span class="n">prestretch</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">],</span> <span class="n">prestretch</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">],</span> <span class="n">prestretch</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="s1">&#39;F&#39;</span><span class="p">],</span> <span class="n">prestretch</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="s1">&#39;E&#39;</span><span class="p">],</span> <span class="n">prestretch</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="s1">&#39;G&#39;</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="s1">&#39;C&#39;</span><span class="p">],</span> <span class="n">prestretch</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="s1">&#39;C&#39;</span><span class="p">],</span> <span class="n">prestretch</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">],</span> <span class="n">prestretch</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="s1">&#39;J&#39;</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="n">prestretch</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="s1">&#39;K&#39;</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="s1">&#39;D&#39;</span><span class="p">],</span> <span class="n">prestretch</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="s1">&#39;D&#39;</span><span class="p">],</span> <span class="n">prestretch</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="s1">&#39;N&#39;</span><span class="p">],</span> <span class="n">prestretch</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="s1">&#39;N&#39;</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="s1">&#39;M&#39;</span><span class="p">],</span> <span class="n">prestretch</span><span class="p">))</span></div>


<div class="viewcode-block" id="Epithelium.duplicate_cell"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.duplicate_cell">[docs]</a>    <span class="k">def</span> <span class="nf">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_to_copy</span><span class="p">,</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Duplicates a cell in the tissue, with a specified shift in x and y coords</span>

<span class="sd">        :param cell_to_copy:  Identity of cell that will be duplicated</span>
<span class="sd">        :type cell_to_copy: string</span>
<span class="sd">        :param x_shift:   Translation in x-direction.</span>
<span class="sd">        :type x_shift: flaot</span>
<span class="sd">        :param y_shift:  Translation in y-direction.</span>
<span class="sd">        :type y_shift: float</span>
<span class="sd">        :param roll:  (Default value = 0)  Roll the cell variables to change position of starting index.</span>
<span class="sd">        :type roll: int</span>
<span class="sd">        :param theta_shift:  (Default value = 0)  Shift theta by a scale factor (multiples of 2pi).</span>
<span class="sd">        :type theta_shift: float</span>
<span class="sd">        :param identifier:  (Default value = &#39;B&#39;)  Identitfier for new cell.</span>
<span class="sd">        :type identifier: string</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_cell</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cell_to_copy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_cell</span><span class="p">)</span>

        <span class="c1"># Get members of A</span>
        <span class="n">members_of_A</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">cell_to_copy</span><span class="p">)</span> <span class="k">if</span>
                        <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cell_to_copy</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)]</span>
        <span class="c1"># Make a deep copy each member</span>
        <span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="n">members_of_A</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_cell</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cell_to_copy</span><span class="p">,</span> <span class="n">member</span><span class="p">)))</span>

        <span class="n">new_cell</span><span class="o">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="n">identifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">identifier</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_cell</span>

        <span class="c1"># Update position in tissue</span>
        <span class="n">new_cell</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">x_shift</span>
        <span class="n">new_cell</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">y_shift</span>
        <span class="n">new_cell</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">new_cell</span><span class="o">.</span><span class="n">theta</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="n">new_cell</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">new_cell</span><span class="o">.</span><span class="n">C</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="n">new_cell</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">new_cell</span><span class="o">.</span><span class="n">D</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="n">new_cell</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">new_cell</span><span class="o">.</span><span class="n">gamma</span> <span class="o">+</span> <span class="mf">0.</span>

        <span class="c1"># Roll if requested</span>
        <span class="k">if</span> <span class="n">roll</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_cell</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">new_cell</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">roll</span><span class="p">)</span>
            <span class="n">new_cell</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">new_cell</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">roll</span><span class="p">)</span>
            <span class="n">new_cell</span><span class="o">.</span><span class="n">theta</span> <span class="o">+=</span> <span class="n">theta_shift</span>
            <span class="n">new_cell</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">new_cell</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="n">roll</span><span class="p">)</span>
            <span class="n">new_cell</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">new_cell</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">roll</span><span class="p">)</span>
            <span class="n">new_cell</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">new_cell</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="n">roll</span><span class="p">)</span>
            <span class="n">new_cell</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">new_cell</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">roll</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_build_single_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">param_dict</span><span class="o">=</span><span class="p">{},</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">cell_kwargs</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot; Create a new, circular cell in the tissue.</span>

<span class="sd">        :param radius: (Default value = 35)  Radius of new cell.</span>
<span class="sd">        :type radius: float</span>
<span class="sd">        :param n:  (Default value = 2000)  Size of mesh for cell.</span>
<span class="sd">        :type n: int</span>
<span class="sd">        :param param_dict: param verbose: (Default value = {})  kappa, omega0, delta param dictionary.</span>
<span class="sd">        :type param_dict: dict</span>
<span class="sd">        :param identifier:  (Default value = &#39;A&#39;)  Optional paramters for cell.</span>
<span class="sd">        :type identifier: string</span>
<span class="sd">        :param verbose: Whether to print information to console. (Default value = False)</span>
<span class="sd">        :type verbose:  bool</span>
<span class="sd">        :param cell_kwargs:  (Default value = {})  Optional parameters for cell.</span>
<span class="sd">        :type cell_kwargs: dict</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Creating 1 cell in hexagon&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Initialise circle A</span>
        <span class="n">circle_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">radius</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span>  <span class="c1"># / 2</span>
        <span class="n">anglesA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">anglesA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">anglesA</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">anglesA</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">pointsXA</span> <span class="o">=</span> <span class="p">(</span><span class="n">circle_radius</span> <span class="o">-</span> <span class="n">delta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">anglesA</span><span class="p">)</span>
        <span class="n">pointsYA</span> <span class="o">=</span> <span class="p">(</span><span class="n">circle_radius</span> <span class="o">-</span> <span class="n">delta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">anglesA</span><span class="p">)</span>
        <span class="n">anglesA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># Make closed loop</span>
        <span class="n">pointsXA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pointsXA</span><span class="p">,</span> <span class="n">pointsXA</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Add the bottom point to make a closed loop</span>
        <span class="n">pointsYA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pointsYA</span><span class="p">,</span> <span class="n">pointsYA</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Add the bottom point to make a closed loop</span>
        <span class="n">anglesA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">anglesA</span><span class="p">,</span> <span class="n">anglesA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>  <span class="c1"># Add the bottom point to make a closed loop</span>

        <span class="n">total_points</span> <span class="o">=</span> <span class="n">anglesA</span><span class="o">.</span><span class="n">size</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="n">total_points</span>

        <span class="c1"># Do the curvatures</span>
        <span class="n">c_guessA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">anglesA</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Do the curvatures derivatives</span>
        <span class="n">d_guessA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">c_guessA</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># np.linspace(0, 0, total_points)</span>
        <span class="c1"># TAUS</span>
        <span class="n">gamma_guessA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">anglesA</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="c1"># We just build the first cell and then create all other instances from this cell.</span>
        <span class="n">initial_guessesA</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="n">d_guessA</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">c_guessA</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">gamma_guessA</span><span class="p">,</span> <span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="n">anglesA</span><span class="p">,</span>
                            <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">pointsXA</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">pointsYA</span><span class="p">}</span>
        <span class="n">cellA</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="n">initial_guesses</span><span class="o">=</span><span class="n">initial_guessesA</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">param_dict</span><span class="o">=</span><span class="n">param_dict</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="n">identifier</span><span class="p">,</span>
                     <span class="n">cell_kwargs</span><span class="o">=</span><span class="n">cell_kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="p">[</span><span class="n">cellA</span><span class="p">]</span>
        <span class="c1"># Dictionary to point to cells</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>


<div class="viewcode-block" id="Epithelium.create_3_cell_eptm_from_fitted_single_cell"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.create_3_cell_eptm_from_fitted_single_cell">[docs]</a>    <span class="k">def</span> <span class="nf">create_3_cell_eptm_from_fitted_single_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tissue with 3 cells enclosed in a stencil.  Need to start with a single cell in a hexagon.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Creating eptm from cell A in hexagon&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># copy a cortices. Warning: the immutable objects are copied as references, but I think this is ok</span>
        <span class="c1"># because they are always reassigned rather than edited.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">within_hexagons</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">cellB</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">cellC</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">cellB</span><span class="p">,</span> <span class="n">cellC</span><span class="p">])</span>

        <span class="c1"># Make deep copies of all member variables \todo (this is hacky...)</span>
        <span class="c1"># Get members of A</span>
        <span class="n">members_of_A</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span>
                        <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">attr</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)]</span>
        <span class="c1"># Make a deep copy each member</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="n">members_of_A</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">member</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">member</span><span class="p">)))</span>

        <span class="c1"># identifiers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="s1">&#39;B&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="s1">&#39;C&#39;</span>

        <span class="c1"># param dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Get coords of cell A</span>
        <span class="n">xs_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="n">ys_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="n">thetas_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">theta</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="n">c_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">C</span> <span class="o">+</span> <span class="mi">0</span>
        <span class="n">gamma_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">gamma</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="n">d_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">D</span> <span class="o">+</span> <span class="mf">0.</span>

        <span class="c1"># Centroid</span>
        <span class="n">centroid_xA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xs_A</span><span class="p">)</span>
        <span class="n">centroid_yA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ys_A</span><span class="p">)</span>

        <span class="n">deltaNew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">rNew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
        <span class="n">numPoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">rNew</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">rNew</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span>

        <span class="n">pointsX</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">6</span><span class="p">),</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">pointsX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pointsX</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">pointsY</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">6</span><span class="p">),</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">pointsY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="n">min_xA</span><span class="p">,</span> <span class="n">min_yA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pointsX</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span>
        <span class="n">max_xA</span><span class="p">,</span> <span class="n">max_yA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsX</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span>

        <span class="c1"># For bounding hexagon</span>
        <span class="n">bounding_points_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">b_coord</span> <span class="k">for</span> <span class="n">b_coord</span> <span class="ow">in</span> <span class="n">pointsX</span><span class="p">]</span>
        <span class="n">bounding_points_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">b_coord</span> <span class="k">for</span> <span class="n">b_coord</span> <span class="ow">in</span> <span class="n">pointsY</span><span class="p">]</span>

        <span class="c1">### For B ###</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">xs_A</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">ys_A</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">thetas_A</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">c_A</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">d_A</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma_A</span> <span class="o">+</span> <span class="mf">0.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c1"># self.cells[1].theta = np.roll(self.cells[1].theta, int(numPoints / 2))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">theta</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1">### For C ###</span>
        <span class="c1"># self.cells[2].x = xs_A + 0.5 * (max_xA - min_xA + self.cells[0].delta)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">xs_A</span> <span class="o">+</span> <span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="c1"># 1.5 * np.max(pointsY) + deltaNew * np.sin(np.pi / 3)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">ys_A</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># + 0.5 * self.cells[0].delta * np.cos(np.pi / 3)</span>
        <span class="c1"># self.cells[2].y = ys_A + (max_yA - min_yA + self.cells[0].delta) * np.sin(np.pi / 3)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">thetas_A</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">c_A</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">d_A</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma_A</span> <span class="o">+</span> <span class="mf">0.</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">update_deformed_mesh_spacing</span><span class="p">()</span>

        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1"># Finish up the boundary</span>
        <span class="n">all_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">bounding_points_x</span><span class="p">,</span> <span class="n">bounding_points_y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># This keeps on the hexagon boundaries</span>
        <span class="n">hull</span> <span class="o">=</span> <span class="n">ConcaveHull</span><span class="p">()</span>
        <span class="n">hull</span><span class="o">.</span><span class="n">loadpoints</span><span class="p">(</span><span class="n">all_points</span><span class="p">)</span>
        <span class="n">hull</span><span class="o">.</span><span class="n">calculatehull</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">concave_hull_tolerance</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">scaled_boundary</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">hull</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">exterior</span><span class="p">,</span> <span class="n">xfact</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">yfact</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zfact</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;centroid&#39;</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">scaled_boundary</span><span class="o">.</span><span class="n">xy</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># Save</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">update_deformed_mesh_spacing</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span> <span class="o">=</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="Epithelium.create_14_cell_eptm_from_fitted_single_cell"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.create_14_cell_eptm_from_fitted_single_cell">[docs]</a>    <span class="k">def</span> <span class="nf">create_14_cell_eptm_from_fitted_single_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Build a 14-cell tissue, symmetric in x and y, from a tissue made up of a single cell in a hexagon.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Creating eptm from cell A in hexagon&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># copy a cortices. Warning: the immutable objects are copied as references, but I think this is ok</span>
        <span class="c1"># because they are always reassigned rather than edited.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">within_hexagons</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Get coords of cell A</span>
        <span class="n">xs_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="n">ys_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="c1"># Centroid</span>
        <span class="n">centroid_xA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xs_A</span><span class="p">)</span>
        <span class="n">centroid_yA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ys_A</span><span class="p">)</span>

        <span class="c1"># Calculations for bounding hexagon</span>
        <span class="n">deltaNew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">rNew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
        <span class="n">numPoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">rNew</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">rNew</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span>

        <span class="n">pointsX</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">6</span><span class="p">),</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">pointsX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pointsX</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">pointsY</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">6</span><span class="p">),</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">pointsY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="n">min_xA</span><span class="p">,</span> <span class="n">min_yA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pointsX</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span>
        <span class="n">max_xA</span><span class="p">,</span> <span class="n">max_yA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsX</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span>

        <span class="c1"># For bounding stencil</span>
        <span class="n">bounding_points_x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bounding_points_y</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># B</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">theta_shift</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="c1"># C</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="c1"># D</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
        <span class="c1"># E</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;E&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1"># F</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1"># G</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;G&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">-</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="c1"># For H</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="c1"># For I</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;I&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># For J</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;J&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># For K</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">-</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1">### For L ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1">### For M ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1">### For N ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">update_deformed_mesh_spacing</span><span class="p">()</span>

        <span class="c1">###### Update the boundary #######</span>
        <span class="n">all_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">bounding_points_x</span><span class="p">,</span> <span class="n">bounding_points_y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># This keeps on the hexagon boundaries</span>
        <span class="n">hull</span> <span class="o">=</span> <span class="n">ConcaveHull</span><span class="p">()</span>
        <span class="n">hull</span><span class="o">.</span><span class="n">loadpoints</span><span class="p">(</span><span class="n">all_points</span><span class="p">)</span>
        <span class="n">hull</span><span class="o">.</span><span class="n">calculatehull</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">concave_hull_tolerance</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Scale it</span>
        <span class="n">scaled_boundary</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">hull</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">exterior</span><span class="p">,</span> <span class="n">xfact</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">yfact</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zfact</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;centroid&#39;</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">scaled_boundary</span><span class="o">.</span><span class="n">xy</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># Save</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">update_deformed_mesh_spacing</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span> <span class="o">=</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="Epithelium.create_17_cell_eptm_from_fitted_single_cell"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.create_17_cell_eptm_from_fitted_single_cell">[docs]</a>    <span class="k">def</span> <span class="nf">create_17_cell_eptm_from_fitted_single_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a tissue with 17 cells and two axes of symmetry from a tissue with a single cell in a hexagon.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Creating eptm from cell A in hexagon&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># copy a cortices. Warning: the immutable objects are copied as references, but I think this is ok</span>
        <span class="c1"># because they are always reassigned rather than edited.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">within_hexagons</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Get coords of cell A</span>
        <span class="n">xs_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="n">ys_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="c1"># Centroid</span>
        <span class="n">centroid_xA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xs_A</span><span class="p">)</span>
        <span class="n">centroid_yA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ys_A</span><span class="p">)</span>

        <span class="c1"># Calculations for bounding hexagon</span>
        <span class="n">deltaNew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">rNew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
        <span class="n">numPoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">rNew</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">rNew</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span>

        <span class="n">pointsX</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">6</span><span class="p">),</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">pointsX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pointsX</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">pointsY</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">6</span><span class="p">),</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">pointsY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="n">min_xA</span><span class="p">,</span> <span class="n">min_yA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pointsX</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span>
        <span class="n">max_xA</span><span class="p">,</span> <span class="n">max_yA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsX</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span>

        <span class="c1"># For bounding stencil</span>
        <span class="n">bounding_points_x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bounding_points_y</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># B</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">theta_shift</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="c1"># C</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="c1"># D</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
        <span class="c1"># E</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;E&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1"># F</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1"># G</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;G&#39;</span><span class="p">)</span>
        <span class="c1"># For H</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="c1"># For I</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;I&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="n">x_shift</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="n">y_shift</span><span class="p">)</span>
        <span class="c1"># For J</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;J&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># For K</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="n">x_shift</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="n">y_shift</span><span class="p">)</span>
        <span class="c1">### For L ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1">### For M ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1">### For N ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1">### For O ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;O&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1">### For P ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="c1">### For Q ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;Q&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="n">x_shift</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1">### For R ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="n">x_shift</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">update_deformed_mesh_spacing</span><span class="p">()</span>

        <span class="c1"># Prestrain dict</span>
        <span class="n">p_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                  <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                  <span class="s1">&#39;boundary&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span> <span class="o">=</span> <span class="n">p_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">adhesion_density_dict</span> <span class="o">=</span> <span class="n">p_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


        <span class="c1">###### Update the boundary #######</span>
        <span class="n">all_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">bounding_points_x</span><span class="p">,</span> <span class="n">bounding_points_y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># This keeps on the hexagon boundaries</span>
        <span class="n">hull</span> <span class="o">=</span> <span class="n">ConcaveHull</span><span class="p">()</span>
        <span class="n">hull</span><span class="o">.</span><span class="n">loadpoints</span><span class="p">(</span><span class="n">all_points</span><span class="p">)</span>
        <span class="n">hull</span><span class="o">.</span><span class="n">calculatehull</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">concave_hull_tolerance</span><span class="o">*</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Scale it</span>
        <span class="n">scaled_boundary</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">hull</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">exterior</span><span class="p">,</span> <span class="n">xfact</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">yfact</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zfact</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;centroid&#39;</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">scaled_boundary</span><span class="o">.</span><span class="n">xy</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># Save</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">update_deformed_mesh_spacing</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span> <span class="o">=</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="Epithelium.create_19_cell_eptm_from_fitted_single_cell"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.create_19_cell_eptm_from_fitted_single_cell">[docs]</a>    <span class="k">def</span> <span class="nf">create_19_cell_eptm_from_fitted_single_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build a tissue with 19 cells from a tissue with a single cell enclosed in a hexagon.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Creating eptm from cell A in hexagon&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># copy a cortices. Warning: the immutable objects are copied as references, but I think this is ok</span>
        <span class="c1"># because they are always reassigned rather than edited.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">within_hexagons</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Get coords of cell A</span>
        <span class="n">xs_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="n">ys_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="c1"># Centroid</span>
        <span class="n">centroid_xA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xs_A</span><span class="p">)</span>
        <span class="n">centroid_yA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ys_A</span><span class="p">)</span>

        <span class="c1"># Calculations for bounding hexagon</span>
        <span class="n">deltaNew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">rNew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
        <span class="n">numPoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">rNew</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">rNew</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span>

        <span class="n">pointsX</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">6</span><span class="p">),</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">pointsX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pointsX</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">pointsY</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">6</span><span class="p">),</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">pointsY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="n">min_xA</span><span class="p">,</span> <span class="n">min_yA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pointsX</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span>
        <span class="n">max_xA</span><span class="p">,</span> <span class="n">max_yA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsX</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span>

        <span class="c1"># For bounding stencil</span>
        <span class="n">bounding_points_x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bounding_points_y</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># B</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">numPoints</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">theta_shift</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="c1"># C</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="c1"># D</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
        <span class="c1"># E</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;E&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1"># F</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1"># G</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;G&#39;</span><span class="p">)</span>
        <span class="c1"># For H</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="c1"># For I</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;I&#39;</span><span class="p">)</span>
        <span class="c1"># For J</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;J&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># For K</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
        <span class="c1">### For L ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1">### For M ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1">### For N ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1">### For O ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;O&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1">### For P ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="c1">### For Q ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;Q&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1">### For R ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="c1">### For S ###</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">y_shift</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
        <span class="c1"># Its at boundary</span>
        <span class="n">bounding_points_x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsX</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_xA</span> <span class="o">-</span> <span class="n">centroid_xA</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>
        <span class="n">bounding_points_y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pointsY</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pointsY</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)))</span>

        <span class="c1"># Prestrain dict</span>
        <span class="n">p_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                  <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                  <span class="s1">&#39;boundary&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span> <span class="o">=</span> <span class="n">p_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">adhesion_density_dict</span> <span class="o">=</span> <span class="n">p_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


        <span class="c1">###### Update the boundary #######</span>
        <span class="n">all_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">bounding_points_x</span><span class="p">,</span> <span class="n">bounding_points_y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># This keeps on the hexagon boundaries</span>
        <span class="n">hull</span> <span class="o">=</span> <span class="n">ConcaveHull</span><span class="p">()</span>
        <span class="n">hull</span><span class="o">.</span><span class="n">loadpoints</span><span class="p">(</span><span class="n">all_points</span><span class="p">)</span>
        <span class="n">hull</span><span class="o">.</span><span class="n">calculatehull</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">concave_hull_tolerance</span><span class="o">*</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Scale it</span>
        <span class="n">scaled_boundary</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">hull</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">exterior</span><span class="p">,</span> <span class="n">xfact</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">yfact</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zfact</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;centroid&#39;</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">scaled_boundary</span><span class="o">.</span><span class="n">xy</span>

        <span class="c1"># Save</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span> <span class="o">=</span> <span class="p">[]</span></div>


    <span class="k">def</span> <span class="nf">_get_convex_hull_area_of_centroids_with_radii</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centroids</span><span class="p">,</span> <span class="n">radii</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper method for initialising a disordered tissue. Calculates the convex area of a cluster of round cells,</span>
<span class="sd">        which is used to make sure they are tightly packed.</span>

<span class="sd">        :param centroids: A list of centroids (x,y) coords for each cell.</span>
<span class="sd">        :type centroids: list</span>
<span class="sd">        :param radii:  A list of cell radii corresponding to those coords.</span>
<span class="sd">        :type radii: list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get boundary coords</span>
        <span class="n">boundary_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Get centroids</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">centroids</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">centroids</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">overlap_penalty</span><span class="p">,</span> <span class="n">circ_areas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">centroids</span><span class="p">):</span>
            <span class="c1"># Radius of current cell</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="n">radii</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Get other cell centroids</span>
            <span class="n">other_cs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">centroids</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centroids</span><span class="p">))</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">i</span><span class="p">])</span>
            <span class="c1"># Other radii</span>
            <span class="n">other_radii</span> <span class="o">=</span> <span class="p">[</span><span class="n">radii</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centroids</span><span class="p">))</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">i</span><span class="p">]</span>
            <span class="c1"># Distance to them</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">([</span><span class="n">c</span><span class="p">],</span> <span class="n">other_cs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">d_idx</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">radius_2</span> <span class="o">=</span> <span class="n">other_radii</span><span class="p">[</span><span class="n">d_idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">radius</span> <span class="o">+</span> <span class="n">radius_2</span><span class="p">:</span>
                    <span class="n">overlap_penalty</span> <span class="o">+=</span> <span class="p">((</span><span class="n">radius</span> <span class="o">+</span> <span class="n">radius_2</span><span class="p">)</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span>

            <span class="c1"># Close to boundary</span>
            <span class="n">min_dist</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">([</span><span class="n">c</span><span class="p">],</span> <span class="n">boundary_coords</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">min_dist</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">:</span>
                <span class="n">overlap_penalty</span> <span class="o">+=</span> <span class="p">(</span><span class="n">radius</span> <span class="o">-</span> <span class="n">min_dist</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span>

            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>

            <span class="n">circ_areas</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span>

            <span class="n">points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">total_area</span> <span class="o">=</span> <span class="n">overlap_penalty</span> <span class="o">+</span> <span class="n">hull</span><span class="o">.</span><span class="n">area</span> <span class="o">-</span> <span class="n">circ_areas</span>

        <span class="k">return</span> <span class="n">total_area</span>


    <span class="k">def</span> <span class="nf">_get_distances_between_centroids_with_radii</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centroids</span><span class="p">,</span> <span class="n">radii</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper method for initialising a disordered tissue. Calculates the distances between cell centroids,</span>
<span class="sd">        which is used to make sure they are tightly packed.</span>

<span class="sd">        :param centroids: A list of centroids (x,y) coords for each cell.</span>
<span class="sd">        :type centroids: list</span>
<span class="sd">        :param radii:  A list of cell radii corresponding to those coords.</span>
<span class="sd">        :type radii: list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get boundary coords</span>
        <span class="n">boundary_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Get centroids</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">centroids</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">centroids</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">cumulative_distances</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">centroids</span><span class="p">):</span>
            <span class="c1"># Radius of current cell</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="n">radii</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Get other cell centroids</span>
            <span class="n">other_cs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">centroids</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centroids</span><span class="p">))</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">i</span><span class="p">])</span>
            <span class="c1"># Other radii</span>
            <span class="n">other_radii</span> <span class="o">=</span> <span class="p">[</span><span class="n">radii</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centroids</span><span class="p">))</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">i</span><span class="p">]</span>
            <span class="c1"># Distance to them</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">([</span><span class="n">c</span><span class="p">],</span> <span class="n">other_cs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">d_idx</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">radius_2</span> <span class="o">=</span> <span class="n">other_radii</span><span class="p">[</span><span class="n">d_idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">radius</span> <span class="o">+</span> <span class="n">radius_2</span><span class="p">:</span>
                    <span class="n">scaling</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">radii</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
                    <span class="n">cumulative_distances</span> <span class="o">+=</span> <span class="p">((</span><span class="n">radius</span> <span class="o">+</span> <span class="n">radius_2</span><span class="p">)</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="n">scaling</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cumulative_distances</span> <span class="o">+=</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="p">(</span><span class="n">radius</span> <span class="o">+</span> <span class="n">radius_2</span><span class="p">))</span>

            <span class="c1"># Close to boundary</span>
            <span class="n">min_dist</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">([</span><span class="n">c</span><span class="p">],</span> <span class="n">boundary_coords</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">min_dist</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">:</span>
                <span class="n">cumulative_distances</span> <span class="o">+=</span> <span class="p">(</span><span class="n">radius</span> <span class="o">-</span> <span class="n">min_dist</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">cumulative_distances</span>


    <span class="k">def</span> <span class="nf">_pack_centroids_together</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centroids</span><span class="p">,</span> <span class="n">radii</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;Given a list of centroids, define radii based on their relative distances and pack together more densely via minimisation</span>

<span class="sd">        :param centroids:  List of cell centroid (xy) coords.</span>
<span class="sd">        :type centroids: list</span>
<span class="sd">        :param radii:  (Default value = [])  Optional list of radii for those cells.  Otherwise its calculated from centroids.</span>
<span class="sd">        :type radii: list</span>
<span class="sd">        :return centroids:  The new centroid locations after packing.</span>
<span class="sd">        :rtype: list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Packing the centroids together&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">boundary_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># centroids = [[59.19914007469464, -26.433803996836982], [-1.534100787501092, 59.078695551287375], [-52.06592950911108, -10.362478064085945], [32.84152340879301, -93.37408338671601], [73.25750764601091, 43.442251003972224], [-37.463652031344864, -79.68420967046461], [-72.33201585627047, 55.24755184974827], [45.010659331709796, 95.68920399831025], [6.435527624855871, -0.19363773362153852], [-39.89568913568516, 101.37354092790487], [-83.37871347024672, -51.64724193213894], [4.52062124513836, -50.83679363376616]]</span>


        <span class="c1"># Get the radii of the nearest cells</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">radii</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">centroids</span><span class="p">):</span>
            <span class="n">radii</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">centroid</span> <span class="ow">in</span> <span class="n">centroids</span><span class="p">:</span>
                <span class="n">other_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">centroids</span> <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">dist_to_cells</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">centroid</span><span class="p">]),</span> <span class="n">other_cells</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">dist_to_boundary</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">centroid</span><span class="p">]),</span> <span class="n">boundary_coords</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="c1"># Get closest point</span>
                <span class="n">radii</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="n">dist_to_boundary</span><span class="p">,</span> <span class="n">dist_to_cells</span><span class="p">])</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># Past to minimiser</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span>
        <span class="c1"># centroids = minimize(self._get_distances_between_centroids_with_radii, centroids, args=radii,</span>
        <span class="c1">#                      method=&#39;Nelder-Mead&#39;).x</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_distances_between_centroids_with_radii</span><span class="p">,</span> <span class="n">centroids</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">radii</span><span class="p">,</span>
                             <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Powell&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">x</span>
        <span class="c1"># centroids = minimize(self._get_convex_hull_area_of_centroids_with_radii, centroids, args=radii,</span>
        <span class="c1">#                      method=&#39;Powell&#39;).x</span>
        <span class="c1"># centroids = minimize(self._get_convex_hull_area_of_centroids_with_radii, centroids, args=radii,</span>
        <span class="c1">#                      method=&#39;Nelder-Mead&#39;).x  # , options={&#39;fatol&#39;: 1e-10, &#39;xatol&#39;: 1e-10}).x</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">centroids</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">centroids</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">centroids</span>


<div class="viewcode-block" id="Epithelium.create_disordered_tissue_in_ellipse"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.create_disordered_tissue_in_ellipse">[docs]</a>    <span class="k">def</span> <span class="nf">create_disordered_tissue_in_ellipse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a disordered tissue using a matern point process.</span>

<span class="sd">        :param param_dict:  (Default value = None)  kappa, omega0, delta dictionary for cells.</span>
<span class="sd">        :type param_dict: dict</span>
<span class="sd">        :param kwargs: Optional arguments for the tissue.</span>
<span class="sd">        :type kwargs: dict</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Creating disordered eptm&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">max_density</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_density&#39;</span><span class="p">,</span> <span class="mi">15000</span><span class="p">)</span>
        <span class="n">ellipse_minor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ellipse_minor&#39;</span><span class="p">,</span> <span class="mi">120</span><span class="p">)</span>
        <span class="n">ellipse_major</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ellipse_major&#39;</span><span class="p">,</span> <span class="mi">140</span><span class="p">)</span>
        <span class="n">min_radius</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_radius&#39;</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
        <span class="n">max_radius</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_radius&#39;</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>

        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">4090</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ellipse_minor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span> <span class="n">ellipse_major</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
        <span class="n">boundary_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">density</span><span class="p">,</span> <span class="n">temp_max_radius</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_radius</span> <span class="o">+</span> <span class="mi">0</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="n">centroids</span><span class="p">,</span> <span class="n">last_num_centroids</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span>
        <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">density</span> <span class="o">&lt;</span> <span class="n">max_density</span><span class="p">:</span>
                <span class="c1"># Get random point in ellipse</span>
                <span class="n">random_guess</span><span class="p">,</span> <span class="n">random_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">c_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">random_guess</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">random_angle</span><span class="p">)</span>
                <span class="n">c_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">random_guess</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">random_angle</span><span class="p">)</span>
                <span class="n">c_x</span> <span class="o">*=</span> <span class="n">ellipse_minor</span>
                <span class="n">c_y</span> <span class="o">*=</span> <span class="n">ellipse_major</span>

                <span class="n">c_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">c_x</span><span class="p">,</span> <span class="n">c_y</span><span class="p">]])</span>
                <span class="k">if</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">c_guess</span><span class="p">,</span> <span class="n">boundary_coords</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">temp_max_radius</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">centroids</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">c_x</span><span class="p">,</span> <span class="n">c_y</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">c_guess</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centroids</span><span class="p">))</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">temp_max_radius</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">centroids</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">c_x</span><span class="p">,</span> <span class="n">c_y</span><span class="p">])</span>
                        <span class="n">density</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">if</span> <span class="n">density</span> <span class="o">==</span> <span class="n">max_density</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">temp_max_radius</span> <span class="o">-=</span> <span class="mi">2</span>
                    <span class="n">density</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">temp_max_radius</span> <span class="o">&lt;</span> <span class="n">min_radius</span><span class="p">:</span>
                    <span class="n">density</span> <span class="o">=</span> <span class="n">max_density</span>

                <span class="n">density</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">last_num_centroids</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span>
                <span class="n">centroids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pack_centroids_together</span><span class="p">(</span><span class="n">centroids</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">last_num_centroids</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">:</span>
                <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">min_radius</span> <span class="o">=</span> <span class="n">min_radius</span> <span class="o">-</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">min_radius</span> <span class="o">&gt;</span> <span class="n">max_radius</span> <span class="o">/</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">min_radius</span>
            <span class="n">last_num_centroids</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span>
            <span class="n">temp_max_radius</span> <span class="o">=</span> <span class="n">max_radius</span> <span class="o">+</span> <span class="mf">0.</span>
            <span class="n">density</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([])</span>

        <span class="c1"># And rest of the cells:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">alphabet</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="s1">&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">centroid</span> <span class="ow">in</span> <span class="n">centroids</span><span class="p">:</span>
            <span class="c1"># All points excluding this one</span>
            <span class="n">other_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">centroids</span> <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">dist_to_cells</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">centroid</span><span class="p">]),</span> <span class="n">other_cells</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">dist_to_boundary</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">centroid</span><span class="p">]),</span> <span class="n">boundary_coords</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="c1"># Get closest point</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">dist_to_boundary</span><span class="p">,</span> <span class="n">dist_to_cells</span><span class="p">])</span> <span class="o">-</span> <span class="mf">0.5</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
            <span class="c1"># Do the curvatures</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Do the curvatures derivatives</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># np.linspace(0, 0, total_points)</span>
            <span class="c1"># TAUS</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">angles</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

            <span class="c1"># The next id, but making sure it&#39;s unique</span>
            <span class="n">next_id</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">next_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">next_id</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">next_id</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)])</span>

            <span class="c1"># We just build the first cell and then create all other instances from this cell.</span>
            <span class="n">initial_guessesA</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="n">d</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">c</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span> <span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="n">angles</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">}</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="n">initial_guesses</span><span class="o">=</span><span class="n">initial_guessesA</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">param_dict</span><span class="o">=</span><span class="n">param_dict</span><span class="p">,</span> <span class="n">within_hexagon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">identifier</span><span class="o">=</span><span class="n">next_id</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">next_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell</span>

        <span class="c1"># Prestrain and adhesion density dicts</span>
        <span class="c1"># Dictionary for prestrain</span>
        <span class="n">prestrain_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">prestrain_dict</span><span class="p">[</span><span class="s1">&#39;boundary&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">prestrain_dict</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Scaling for omega0 for different cortices e.g. when adhesion less in A-B than A-C.</span>
        <span class="n">adhesion_density_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">adhesion_density_dict</span><span class="p">[</span><span class="s1">&#39;boundary&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">adhesion_density_dict</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">prestrain_dict</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">prestrain_dict</span><span class="p">)</span>
            <span class="n">cell</span><span class="o">.</span><span class="n">adhesion_density_dict</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">adhesion_density_dict</span><span class="p">)</span>

        <span class="c1"># Create the boundary cell</span>
        <span class="n">initial_guesses</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="p">[],</span>
                           <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="n">initial_guesses</span><span class="o">=</span><span class="n">initial_guesses</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;boundary&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span><span class="o">.</span><span class="n">prune_adhesion_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="s1">&#39;boundary&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_cell</span></div>


<div class="viewcode-block" id="Epithelium.pickle_self"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.pickle_self">[docs]</a>    <span class="k">def</span> <span class="nf">pickle_self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SAVE_DIR</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prune_adhesions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pickles and saves an instance of this class in its current state.</span>

<span class="sd">        :param SAVE_DIR: (Default value = None)  Save location.</span>
<span class="sd">        :type SAVE_DIR: string</span>
<span class="sd">        :param name:  (Default value = None)  Filename</span>
<span class="sd">        :type name: string</span>
<span class="sd">        :param prune_adhesions: (Default value = True)  Remove fast adhesions and cell-stored adhesions before saving (recommended for space).</span>
<span class="sd">        :type prune_adhesions : bool</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Saving T1 objects&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">prune_adhesions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
                <span class="n">cell</span><span class="o">.</span><span class="n">prune_adhesion_data</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_bc</span> <span class="o">!=</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">SAVE_DIR</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">SAVE_DIR</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;..&#39;</span><span class="p">,</span> <span class="s1">&#39;initial_conditions&#39;</span><span class="p">))</span>
        <span class="c1"># Make sure the directory exists</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">SAVE_DIR</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">SAVE_DIR</span><span class="p">)</span>
        <span class="c1"># Filename</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;T1_omega0_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">omega0</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="s1">&#39;_pressure_&#39;</span> \
                   <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pressure</span><span class="p">)</span>

        <span class="c1"># saveloc</span>
        <span class="n">saveloc</span> <span class="o">=</span> <span class="n">SAVE_DIR</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">name</span>
        <span class="c1"># Pickle</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">saveloc</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">dill</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span></div>


<div class="viewcode-block" id="Epithelium.plot_bijunction_tension_arrows"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.plot_bijunction_tension_arrows">[docs]</a>    <span class="k">def</span> <span class="nf">plot_bijunction_tension_arrows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_list</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_extra_indices</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">arrow_col</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
                                       <span class="n">arrow_scale</span><span class="o">=.</span><span class="mi">015</span><span class="p">,</span> <span class="n">arrow_width</span><span class="o">=</span><span class="mf">0.004</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot arrows representing magnitude of tension in cortex</span>

<span class="sd">        :param cell_list:  List of cell idetifiers on which arrows will be plotted.</span>
<span class="sd">        :type cell_list: list</span>
<span class="sd">        :param ax:  (Default value = None)  Axis on which to plot.</span>
<span class="sd">        :type ax: mpl axis</span>
<span class="sd">        :param num_extra_indices:  (Default value = 2)  Average the force over a few indices.</span>
<span class="sd">        :type num_extra_indices: int</span>
<span class="sd">        :param arrow_scale:  (Default value = .015)  Scale the matplotlib arrow.</span>
<span class="sd">        :type arrow_scale: float</span>
<span class="sd">        :param arrow_col:  (Default value = &#39;k&#39;)  Arrow colour.</span>
<span class="sd">        :type arrow_col: string</span>
<span class="sd">        :param arrow_width:  (Default value = 0.004)  Width of arrow.</span>
<span class="sd">        :type arrow_width: float</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cell_list</span><span class="p">:</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span>
            <span class="n">forces_t</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">gamma</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">bi_junc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bicellular_junctions_for_cell</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">identifier</span><span class="p">):</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">((</span><span class="n">cell</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">bi_junc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">cell</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">bi_junc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">bi_junc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">cell</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">bi_junc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
                <span class="k">for</span> <span class="n">j_end</span> <span class="ow">in</span> <span class="n">bi_junc</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">j_end</span><span class="p">],</span> <span class="n">cell</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">j_end</span><span class="p">]</span>
                    <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="k">if</span> <span class="n">j_end</span> <span class="o">==</span> <span class="n">bi_junc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">theta</span>
                    <span class="n">force</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">forces_t</span><span class="p">[</span><span class="n">j_end</span> <span class="o">-</span> <span class="n">num_extra_indices</span><span class="p">:</span><span class="n">j_end</span> <span class="o">+</span> <span class="n">num_extra_indices</span><span class="p">])</span> \
                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)])</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">force</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">force</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">width</span><span class="o">=</span><span class="n">arrow_width</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">arrow_scale</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">arrow_col</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></div>


<div class="viewcode-block" id="Epithelium.plot_xy_on_trijunction"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.plot_xy_on_trijunction">[docs]</a>    <span class="k">def</span> <span class="nf">plot_xy_on_trijunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axEqual</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plotAdhesion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_stress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">plot_adhesion_forces</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_boundary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cell_ids</span><span class="o">=</span><span class="p">[],</span>
                               <span class="n">lagrangian_tracking</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_tension</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_boundary_movement</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">plot_cbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">cell_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">sim_type</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the tissue and the boundary.</span>

<span class="sd">        :param ax: (Default value = None)  Axis object to plot on.</span>
<span class="sd">        :type ax: mpl axis</span>
<span class="sd">        :param plotAdhesion: (Default value = True)  Whether to plot adhesions.</span>
<span class="sd">        :type plotAdhesion: bool</span>
<span class="sd">        :param plot_shape: (Default value = False)  Plot the principal axis of shape.</span>
<span class="sd">        :type plot_shape: bool</span>
<span class="sd">        :param plot_boundary: (Default value = True)  Plot the boundary?</span>
<span class="sd">        :type plot_boundary: bool</span>
<span class="sd">        :param lagrangian_tracking: (Default value = False)  Plot Lagrange markers.</span>
<span class="sd">        :type lagrangian_tracking: bool</span>
<span class="sd">        :param plot_boundary_movement: (Default value = True)  Plot the position of the boundary in the last step.</span>
<span class="sd">        :type plot_boundary_movement: bool</span>
<span class="sd">        :param cell_kwargs: (Default value = {})  Optional arguments for plotting the cells.</span>
<span class="sd">        :type cell_kwargs: dict</span>
<span class="sd">        :param axEqual:  (Default value = True)  As in Matplotlib axis.</span>
<span class="sd">        :type axEqual: bool</span>
<span class="sd">        :param plot_stress:  (Default value = False)  Plot the principal axis of stress.</span>
<span class="sd">        :type plot_stress: bool</span>
<span class="sd">        :param plot_adhesion_forces:  (Default value = True)  Plot arrows for the adhesion forces.</span>
<span class="sd">        :type plot_adhesion_forces: bool</span>
<span class="sd">        :param cell_ids:  (Default value = [])  List of cell identifiers to plot.</span>
<span class="sd">        :type cell_ids: list</span>
<span class="sd">        :param plot_tension:  (Default value = False)  Plot the magnitude of tension in cortex with a heatmap.</span>
<span class="sd">        :type plot_tension: bool</span>
<span class="sd">        :param plot_cbar:  (Default value = True)  Plot colourbars for the cell stress and tension.</span>
<span class="sd">        :type plot_cbar: bool</span>
<span class="sd">        :param sim_type:  (Default value = &#39;auto&#39;)  Used to scale the stress colourmaps e.g. if there are lots of cables.</span>
<span class="sd">        :type sim_type: string</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Plotting full T1&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Figure out what type of simulation we did</span>
        <span class="k">if</span> <span class="n">sim_type</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="n">max_prestrain_refs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">([</span><span class="n">pval</span> <span class="k">for</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">pval</span> <span class="o">&lt;</span> <span class="mf">0.9995</span><span class="p">])</span>
                                          <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">max_prestrain_refs</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">sim_type</span> <span class="o">=</span> <span class="s1">&#39;single&#39;</span>
            <span class="k">elif</span> <span class="n">max_prestrain_refs</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">):</span>
                <span class="n">sim_type</span> <span class="o">=</span> <span class="s1">&#39;cable&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sim_type</span> <span class="o">=</span> <span class="s1">&#39;whole&#39;</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cell_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="c1"># Check if pressure or prestrain has been added to any cell</span>
        <span class="n">plot_pressure</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">pressure</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">])</span>

        <span class="c1"># Colourbar for stress</span>
        <span class="n">plot_cbar</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">plot_cbar</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">plot_stress</span> <span class="ow">and</span> <span class="n">plot_cbar</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sim_type</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>
                <span class="n">max_pressure</span> <span class="o">=</span> <span class="mf">6e-4</span>  <span class="c1"># For singe junction</span>
            <span class="k">elif</span> <span class="n">sim_type</span> <span class="o">==</span> <span class="s1">&#39;cable&#39;</span><span class="p">:</span>
                <span class="n">max_pressure</span> <span class="o">=</span> <span class="mf">1.2e-3</span><span class="o">/</span><span class="mi">1</span>  <span class="c1"># For cables</span>
            <span class="k">elif</span> <span class="n">sim_type</span> <span class="o">==</span> <span class="s1">&#39;whole&#39;</span><span class="p">:</span>
                <span class="n">max_pressure</span> <span class="o">=</span> <span class="mf">4e-3</span>  <span class="c1"># For whole cells</span>

            <span class="c1"># Truncate the colourmap to use lighter colours</span>
            <span class="c1"># lower, upper = 5e-4, -5e-4</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">max_pressure</span> <span class="o">*</span> <span class="p">(</span><span class="mf">5.</span> <span class="o">/</span> <span class="mf">6.</span><span class="p">),</span> <span class="o">-</span><span class="n">max_pressure</span> <span class="o">*</span> <span class="p">(</span><span class="mf">5.</span> <span class="o">/</span> <span class="mf">6.</span><span class="p">)</span>
            <span class="n">minColor</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">upper</span> <span class="o">/</span> <span class="n">max_pressure</span><span class="p">)</span>
            <span class="n">maxColor</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">upper</span> <span class="o">/</span> <span class="n">max_pressure</span><span class="p">)</span>
            <span class="n">truncated_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncate_colormap</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;RdBu&quot;</span><span class="p">),</span> <span class="n">minColor</span><span class="p">,</span> <span class="n">maxColor</span><span class="p">)</span>
            <span class="c1"># Normalise about new points</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
            <span class="c1"># Create scaled cmap</span>
            <span class="n">scaled_cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">truncated_map</span><span class="p">)</span>

            <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scaled_cmap</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">OOMFormatter</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="n">mathText</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">location</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span>
                                <span class="n">shrink</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.02</span><span class="p">)</span>
            <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$P^{\mathrm</span><span class="si">{cell}</span><span class="s1">}$&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">26</span><span class="p">)</span>
            <span class="c1"># ticks = np.linspace(lower, upper, 9)</span>
            <span class="c1"># cbar.ax.set_yticklabels([str(np.format_float_positional(tick, precision=4, trim=&#39;-&#39;)) for tick in ticks])</span>

            <span class="c1"># Colourbar for tension</span>
        <span class="k">if</span> <span class="n">plot_tension</span> <span class="ow">and</span> <span class="n">plot_cbar</span><span class="p">:</span>
            <span class="n">max_tension</span> <span class="o">=</span> <span class="mf">0.0025</span>

            <span class="c1"># Truncate the colourmap to use lighter colours</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="o">-</span><span class="n">max_tension</span><span class="p">,</span> <span class="n">max_tension</span>
            <span class="n">minColor</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">upper</span> <span class="o">/</span> <span class="n">max_tension</span><span class="p">)</span>
            <span class="n">maxColor</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">upper</span> <span class="o">/</span> <span class="n">max_tension</span><span class="p">)</span>
            <span class="n">truncated_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncate_colormap</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;seismic&quot;</span><span class="p">),</span> <span class="n">minColor</span><span class="p">,</span> <span class="n">maxColor</span><span class="p">)</span>
            <span class="c1"># Normalise about new points</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
            <span class="c1"># Create scaled cmap</span>
            <span class="n">scaled_cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">truncated_map</span><span class="p">)</span>
            <span class="n">cbar2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scaled_cmap</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">OOMFormatter</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">mathText</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">location</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span> <span class="n">pad</span><span class="o">=.</span><span class="mi">02</span><span class="p">)</span>
            <span class="c1"># cbar2 = plt.colorbar(scaled_cmap, orientation=&quot;vertical&quot;)</span>
            <span class="n">cbar2</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\varepsilon$&#39;</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=-</span><span class="mi">7</span><span class="p">)</span>
            <span class="n">cbar2</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">26</span><span class="p">)</span>
            <span class="c1"># ticks = np.linspace(lower, upper, 9)</span>
            <span class="c1"># cbar2.ax.set_yticklabels([str(np.format_float_positional(tick, precision=4, trim=&#39;-&#39;)) for tick in ticks])</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">plot_adhesion_forces</span> <span class="ow">or</span> <span class="n">plot_tension</span> <span class="ow">or</span> <span class="n">plot_stress</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">adhesion_point_coords</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_points_between_all_cortices</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">cell_ref</span> <span class="ow">in</span> <span class="n">cell_ids</span><span class="p">:</span>
            <span class="c1"># Specify cell label</span>
            <span class="n">cell_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$</span><span class="si">%s</span><span class="s1">$&#39;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cell_ref</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># plot the cell</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="n">cell_ref</span><span class="p">]</span><span class="o">.</span><span class="n">plot_xy_on_trijunction</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">equalAx</span><span class="o">=</span><span class="n">axEqual</span><span class="p">,</span> <span class="n">plotAdhesion</span><span class="o">=</span><span class="n">plotAdhesion</span><span class="p">,</span>
                                                           <span class="n">plot_shape</span><span class="o">=</span><span class="n">plot_shape</span><span class="p">,</span>
                                                           <span class="n">plot_adhesion_forces</span><span class="o">=</span><span class="n">plot_adhesion_forces</span><span class="p">,</span>
                                                           <span class="n">plot_pressure</span><span class="o">=</span><span class="n">plot_pressure</span><span class="p">,</span>
                                                           <span class="n">plot_tension</span><span class="o">=</span><span class="n">plot_tension</span><span class="p">,</span>
                                                           <span class="n">lagrangian_tracking</span><span class="o">=</span><span class="n">lagrangian_tracking</span><span class="p">,</span>
                                                           <span class="n">label</span><span class="o">=</span><span class="n">cell_label</span><span class="p">,</span>
                                                           <span class="n">plot_stress</span><span class="o">=</span><span class="n">plot_stress</span><span class="p">,</span>
                                                           <span class="n">sim_type</span><span class="o">=</span><span class="n">sim_type</span><span class="p">,</span>
                                                           <span class="o">**</span><span class="n">cell_kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">within_hexagons</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">adhesion_point_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cell</span><span class="o">.</span><span class="n">adhesion_point_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">plot_boundary</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axEqual</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">14</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">160</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">167</span><span class="p">,</span> <span class="mi">275</span><span class="p">])</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">140</span><span class="p">,</span> <span class="mi">140</span><span class="p">])</span>
                <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cellDict</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">100</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">143</span><span class="p">,</span> <span class="mi">232</span><span class="p">])</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">148</span><span class="p">,</span> <span class="mi">148</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">160</span><span class="p">])</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">150</span><span class="p">,</span> <span class="mi">150</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">45</span><span class="p">,</span> <span class="mi">95</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="s1">&#39;box&#39;</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">plot_boundary_movement</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_bc</span> <span class="o">!=</span> <span class="s1">&#39;fixed&#39;</span><span class="p">:</span>
            <span class="c1"># a 4x4 box (counterclockwise)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">initial_box_x</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">89.96192087</span><span class="p">,</span> <span class="o">-</span><span class="mf">89.96192087</span><span class="p">,</span> <span class="mf">149.61295261</span><span class="p">,</span> <span class="mf">149.61295261</span><span class="p">,</span> <span class="o">-</span><span class="mf">89.96192087</span><span class="p">]</span>
                <span class="n">initial_box_y</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">138.26794919</span><span class="p">,</span> <span class="mf">138.26794919</span><span class="p">,</span> <span class="mf">138.26794919</span><span class="p">,</span> <span class="o">-</span><span class="mf">138.26794919</span><span class="p">,</span> <span class="o">-</span><span class="mf">138.26794919</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> \
                               <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> \
                               <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_boundary_adhesions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">initial_box_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">min_x</span><span class="p">,</span> <span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">min_x</span><span class="p">]</span>
                <span class="n">initial_box_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">min_y</span><span class="p">]</span>

            <span class="c1"># a 2x2 hole in the box (clockwise)</span>
            <span class="n">current_min_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">current_max_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_adhesions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">current_box_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_min_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">current_min_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">current_max_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                             <span class="n">current_max_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">current_min_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">current_box_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_min_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">current_max_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">current_max_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">current_min_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">current_min_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># if you don&#39;t specify a color, you will see a seam</span>
            <span class="c1"># plt.fill(current_box_x + initial_box_x, current_box_y + initial_box_y, color=&#39;#a6a6a6&#39;)</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">current_box_x</span><span class="p">,</span> <span class="n">current_box_y</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">initial_box_x</span><span class="p">,</span> <span class="n">initial_box_y</span><span class="p">,</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Epithelium.OOMFormatter"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.OOMFormatter">[docs]</a>    <span class="k">class</span> <span class="nc">OOMFormatter</span><span class="p">(</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">ticker</span><span class="o">.</span><span class="n">ScalarFormatter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fformat</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%1.1f</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mathText</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">oom</span> <span class="o">=</span> <span class="n">order</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fformat</span> <span class="o">=</span> <span class="n">fformat</span>
            <span class="n">matplotlib</span><span class="o">.</span><span class="n">ticker</span><span class="o">.</span><span class="n">ScalarFormatter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">useOffset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">useMathText</span><span class="o">=</span><span class="n">mathText</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_set_order_of_magnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orderOfMagnitude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oom</span>

        <span class="k">def</span> <span class="nf">_set_format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">            :param vmin:  (Default value = None)</span>
<span class="sd">            :param vmax:  (Default value = None)</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fformat</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_useMathText</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$\mathdefault{</span><span class="si">%s</span><span class="s1">}$&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span></div>


<div class="viewcode-block" id="Epithelium.truncate_colormap"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.truncate_colormap">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">truncate_colormap</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">minval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">maxval</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Truncate a colourmap between 2 values</span>

<span class="sd">        :param cmap: A matplotlib colourmap.</span>
<span class="sd">        :param cmap: mpl cmap</span>
<span class="sd">        :param minval:  (Default value = 0.0)  New max value for the colourmap.</span>
<span class="sd">        :param minval:  (Default value = 0.0)  float</span>
<span class="sd">        :param maxval:  (Default value = 1.0)  New min value for colourmap.</span>
<span class="sd">        :param maxval:  (Default value = 1.0)  float</span>
<span class="sd">        :param n:  (Default value = 1000)  Number of values in cmap.</span>
<span class="sd">        :param n:  (Default value = 1000)  int</span>
<span class="sd">        :return:  The truncaetd cmap</span>
<span class="sd">        :rtype:  mpl cmap</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">LinearSegmentedColormap</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span>
            <span class="s1">&#39;trunc(</span><span class="si">{n}</span><span class="s1">,</span><span class="si">{a:.2f}</span><span class="s1">,</span><span class="si">{b:.2f}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">cmap</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">minval</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">maxval</span><span class="p">),</span>
            <span class="n">cmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">,</span> <span class="n">n</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">new_cmap</span></div>


<div class="viewcode-block" id="Epithelium.rotate_curve_about_line"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.rotate_curve_about_line">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">rotate_curve_about_line</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For plotting the symmetric junctions, rotate the soln</span>
<span class="sd">        m is gradient.</span>

<span class="sd">        :param x:  x-coords of the line.</span>
<span class="sd">        :type x: np.arrays</span>
<span class="sd">        :param y:  y-coords of the line.</span>
<span class="sd">        :type y: np.array</span>
<span class="sd">        :param m:  Gradient of line</span>
<span class="sd">        :type m:  float</span>
<span class="sd">        :param c:  (Default value = None)  y-intercept</span>
<span class="sd">        :type c:  float</span>
<span class="sd">        :return:  The new (x,y) arrays representing the line coordinates.</span>
<span class="sd">        :rtype:  tuple</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">m</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">x_</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">d</span> <span class="o">-</span> <span class="n">x</span>
        <span class="n">y_</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">m</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">)</span></div>


<div class="viewcode-block" id="Epithelium.get_indices_to_order_anticlockwise"><a class="viewcode-back" href="../rst/eptm_class.html#eptm_class.Epithelium.get_indices_to_order_anticlockwise">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_indices_to_order_anticlockwise</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">centroid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Order a given set of points anticlockwise, centroid calculated from points if not given</span>

<span class="sd">        :param points:  Input array of (x,y) coord pairs.</span>
<span class="sd">        :type points: np.array</span>
<span class="sd">        :param centroid:  (Default value = None)  Centroid of points. Can also calculate on the fly.</span>
<span class="sd">        :type centroid:  tuple</span>
<span class="sd">        :return:  The indices that order the list.</span>
<span class="sd">        :rtype:  list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">centroid</span><span class="p">:</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># Order the points anticlockwise</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">index_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">angles</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">index_list</span></div></div>



<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Alexander Nestor-Bergmann.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>